<!DOCTYPE html>
<html lang="en"><head>
<script src="../libs/clipboard/clipboard.min.js"></script>
<script src="../libs/quarto-html/tabby.min.js"></script>
<script src="../libs/quarto-html/popper.min.js"></script>
<script src="../libs/quarto-html/tippy.umd.min.js"></script>
<link href="../libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../libs/quarto-html/light-border.css" rel="stylesheet">
<link href="../libs/quarto-html/quarto-html.min.css" rel="stylesheet" data-mode="light">
<link href="../libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.4.554">

  <title>Model Selection - Part A</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="../libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      { color: #24292e;  }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #24292e; } /* Normal */
    code span.al { color: #ff5555; font-weight: bold; } /* Alert */
    code span.an { color: #6a737d; } /* Annotation */
    code span.at { color: #d73a49; } /* Attribute */
    code span.bn { color: #005cc5; } /* BaseN */
    code span.bu { color: #d73a49; } /* BuiltIn */
    code span.cf { color: #d73a49; } /* ControlFlow */
    code span.ch { color: #032f62; } /* Char */
    code span.cn { color: #005cc5; } /* Constant */
    code span.co { color: #6a737d; } /* Comment */
    code span.cv { color: #6a737d; } /* CommentVar */
    code span.do { color: #6a737d; } /* Documentation */
    code span.dt { color: #d73a49; } /* DataType */
    code span.dv { color: #005cc5; } /* DecVal */
    code span.er { color: #ff5555; text-decoration: underline; } /* Error */
    code span.ex { color: #d73a49; font-weight: bold; } /* Extension */
    code span.fl { color: #005cc5; } /* Float */
    code span.fu { color: #6f42c1; } /* Function */
    code span.im { color: #032f62; } /* Import */
    code span.in { color: #6a737d; } /* Information */
    code span.kw { color: #d73a49; } /* Keyword */
    code span.op { color: #24292e; } /* Operator */
    code span.ot { color: #6f42c1; } /* Other */
    code span.pp { color: #d73a49; } /* Preprocessor */
    code span.re { color: #6a737d; } /* RegionMarker */
    code span.sc { color: #005cc5; } /* SpecialChar */
    code span.ss { color: #032f62; } /* SpecialString */
    code span.st { color: #032f62; } /* String */
    code span.va { color: #e36209; } /* Variable */
    code span.vs { color: #032f62; } /* VerbatimString */
    code span.wa { color: #ff5555; } /* Warning */
  </style>
  <link rel="stylesheet" href="../libs/revealjs/dist/theme/quarto.css">
  <link rel="stylesheet" href="../slides_quarto.css">
  <link href="../libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="../libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="../libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="../libs/revealjs/plugin/reveal-chalkboard/font-awesome/css/all.css" rel="stylesheet">
  <link href="../libs/revealjs/plugin/reveal-chalkboard/style.css" rel="stylesheet">
  <link href="../libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">

  .callout {
    margin-top: 1em;
    margin-bottom: 1em;  
    border-radius: .25rem;
  }

  .callout.callout-style-simple { 
    padding: 0em 0.5em;
    border-left: solid #acacac .3rem;
    border-right: solid 1px silver;
    border-top: solid 1px silver;
    border-bottom: solid 1px silver;
    display: flex;
  }

  .callout.callout-style-default {
    border-left: solid #acacac .3rem;
    border-right: solid 1px silver;
    border-top: solid 1px silver;
    border-bottom: solid 1px silver;
  }

  .callout .callout-body-container {
    flex-grow: 1;
  }

  .callout.callout-style-simple .callout-body {
    font-size: 1rem;
    font-weight: 400;
  }

  .callout.callout-style-default .callout-body {
    font-size: 0.9rem;
    font-weight: 400;
  }

  .callout.callout-titled.callout-style-simple .callout-body {
    margin-top: 0.2em;
  }

  .callout:not(.callout-titled) .callout-body {
      display: flex;
  }

  .callout:not(.no-icon).callout-titled.callout-style-simple .callout-content {
    padding-left: 1.6em;
  }

  .callout.callout-titled .callout-header {
    padding-top: 0.2em;
    margin-bottom: -0.2em;
  }

  .callout.callout-titled .callout-title  p {
    margin-top: 0.5em;
    margin-bottom: 0.5em;
  }
    
  .callout.callout-titled.callout-style-simple .callout-content  p {
    margin-top: 0;
  }

  .callout.callout-titled.callout-style-default .callout-content  p {
    margin-top: 0.7em;
  }

  .callout.callout-style-simple div.callout-title {
    border-bottom: none;
    font-size: .9rem;
    font-weight: 600;
    opacity: 75%;
  }

  .callout.callout-style-default  div.callout-title {
    border-bottom: none;
    font-weight: 600;
    opacity: 85%;
    font-size: 0.9rem;
    padding-left: 0.5em;
    padding-right: 0.5em;
  }

  .callout.callout-style-default div.callout-content {
    padding-left: 0.5em;
    padding-right: 0.5em;
  }

  .callout.callout-style-simple .callout-icon::before {
    height: 1rem;
    width: 1rem;
    display: inline-block;
    content: "";
    background-repeat: no-repeat;
    background-size: 1rem 1rem;
  }

  .callout.callout-style-default .callout-icon::before {
    height: 0.9rem;
    width: 0.9rem;
    display: inline-block;
    content: "";
    background-repeat: no-repeat;
    background-size: 0.9rem 0.9rem;
  }

  .callout-title {
    display: flex
  }
    
  .callout-icon::before {
    margin-top: 1rem;
    padding-right: .5rem;
  }

  .callout.no-icon::before {
    display: none !important;
  }

  .callout.callout-titled .callout-body > .callout-content > :last-child {
    padding-bottom: 0.5rem;
    margin-bottom: 0;
  }

  .callout.callout-titled .callout-icon::before {
    margin-top: .5rem;
    padding-right: .5rem;
  }

  .callout:not(.callout-titled) .callout-icon::before {
    margin-top: 1rem;
    padding-right: .5rem;
  }

  /* Callout Types */

  div.callout-note {
    border-left-color: #4582ec !important;
  }

  div.callout-note .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAEU0lEQVRYCcVXTWhcVRQ+586kSUMMxkyaElstCto2SIhitS5Ek8xUKV2poatCcVHtUlFQk8mbaaziwpWgglJwVaquitBOfhQXFlqlzSJpFSpIYyXNjBNiTCck7x2/8/LeNDOZxDuEkgOXe++553zfefee+/OYLOXFk3+1LLrRdiO81yNqZ6K9cG0P3MeFaMIQjXssE8Z1JzLO9ls20MBZX7oG8w9GxB0goaPrW5aNMp1yOZIa7Wv6o2ykpLtmAPs/vrG14Z+6d4jpbSKuhdcSyq9wGMPXjonwmESXrriLzFGOdDBLB8Y6MNYBu0dRokSygMA/mrun8MGFN3behm6VVAwg4WR3i6FvYK1T7MHo9BK7ydH+1uurECoouk5MPRyVSBrBHMYwVobG2aOXM07sWrn5qgB60rc6mcwIDJtQrnrEr44kmy+UO9r0u9O5/YbkS9juQckLed3DyW2XV/qWBBB3ptvI8EUY3I9p/67OW+g967TNr3Sotn3IuVlfMLVnsBwH4fsnebJvyGm5GeIUA3jljERmrv49SizPYuq+z7c2H/jlGC+Ghhupn/hcapqmcudB9jwJ/3jvnvu6vu5lVzF1fXyZuZZ7U8nRmVzytvT+H3kilYvH09mLWrQdwFSsFEsxFVs5fK7A0g8gMZjbif4ACpKbjv7gNGaD8bUrlk8x+KRflttr22JEMRUbTUwwDQScyzPgedQHZT0xnx7ujw2jfVfExwYHwOsDTjLdJ2ebmeQIlJ7neo41s/DrsL3kl+W2lWvAga0tR3zueGr6GL78M3ifH0rGXrBC2aAR8uYcIA5gwV8zIE8onoh8u0Fca/ciF7j1uOzEnqcIm59sEXoGc0+z6+H45V1CvAvHcD7THztu669cnp+L0okAeIc6zjbM/24LgGM1gZk7jnRu1aQWoU9sfUOuhrmtaPIO3YY1KLLWZaEO5TKUbMY5zx8W9UJ6elpLwKXbsaZ4EFl7B4bMtDv0iRipKoDQT2sNQI9b1utXFdYisi+wzZ/ri/1m7QfDgEuvgUUEIJPq3DhX/5DWNqIXDOweC2wvIR90Oq3lDpdMIgD2r0dXvGdsEW5H6x6HLRJYU7C69VefO1x8Gde1ZFSJLfWS1jbCnhtOPxmpfv2LXOA2Xk2tvnwKKPFuZ/oRmwBwqRQDcKNeVQkYcOjtWVBuM/JuYw5b6isojIkYxyYAFn5K7ZBF10fea52y8QltAg6jnMqNHFBmGkQ1j+U43HMi2xMar1Nv0zGsf1s8nUsmUtPOOrbFIR8bHFDMB5zL13Gmr/kGlCkUzedTzzmzsaJXhYawnA3UmARpiYj5ooJZiUoxFRtK3X6pgNPv+IZVPcnwbOl6f+aBaO1CNvPW9n9LmCp01nuSaTRF2YxHqZ8DYQT6WsXT+RD6eUztwYLZ8rM+rcPxamv1VQzFUkzFXvkiVrySGQgJNvXHJAxiU3/NwiC03rSf05VBaPtu/Z7/B8Yn/w7eguloAAAAAElFTkSuQmCC');
  }

  div.callout-note.callout-style-default .callout-title {
    background-color: #dae6fb
  }

  div.callout-important {
    border-left-color: #d9534f !important;
  }

  div.callout-important .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAEKklEQVRYCcVXTWhcVRS+575MJym48A+hSRFr00ySRQhURRfd2HYjk2SSTokuBCkU2o0LoSKKraKIBTcuFCoidGFD08nkBzdREbpQ1EDNIv8qSGMFUboImMSZd4/f9zJv8ibJMC8xJQfO3HPPPef7zrvvvnvviIkpC9nsw0UttFunbUhpFzFtarSd6WJkStVMw5xyVqYTvkwfzuf/5FgtkVoB0729j1rjXwThS7Vio+Mo6DNnvLfahoZ+i/o32lULuJ3NNiz7q6+pyAUkJaFF6JwaM2lUJlV0MlnQn5aTRbEu0SEqHUa0A4AdiGuB1kFXRfVyg5d87+Dg4DL6m2TLAub60ilj7A1Ec4odSAc8X95sHh7+ZRPCFo6Fnp7HfU/fBng/hi10CjCnWnJjsxvDNxWw0NfV6Rv5GgP3I3jGWXumdTD/3cbEOP2ZbOZp69yniG3FQ9z1jD7bnBu9Fc2tKGC2q+uAJOQHBDRiZX1x36o7fWBs7J9ownbtO+n0/qWkvW7UPIfc37WgT6ZGR++EOJyeQDSb9UB+DZ1G6DdLDzyS+b/kBCYGsYgJbSQHuThGKRcw5xdeQf8YdNHsc6ePXrlSYMBuSIAFTGAtQo+VuALo4BX83N190NWZWbynBjhOHsmNfFWLeL6v+ynsA58zDvvAC8j5PkbOcXCMg2PZFk3q8MjI7WAG/Dp9AwP7jdGBOOQkAvlFUB+irtm16I1Zw9YBcpGTGXYmk3kQIC/Cds55l+iMI3jqhjAuaoe+am2Jw5GT3Nbz3CkE12NavmzN5+erJW7046n/CH1RO/RVa8lBLozXk9uqykkGAyRXLWlLv5jyp4RFsG5vGVzpDLnIjTWgnRy2Rr+tDKvRc7Y8AyZq10jj8DqXdnIRNtFZb+t/ZRtXcDiVnzpqx8mPcDWxgARUqx0W1QB9MeUZiNrV4qP+Ehc+BpNgATsTX8ozYKL2NtFYAHc84fG7ndxUPr+AR/iQSns7uSUufAymwDOb2+NjK27lEFocm/EE2WpyIy/Hi66MWuMKJn8RvxIcj87IM5Vh9663ziW36kR0HNenXuxmfaD8JC7tfKbrhFr7LiZCrMjrzTeGx+PmkosrkNzW94ObzwocJ7A1HokLolY+AvkTiD/q1H0cN48c5EL8Crkttsa/AXQVDmutfyku0E7jShx49XqV3MFK8IryDhYVbj7Sj2P2eBxwcXoe8T8idsKKPRcnZw1b+slFTubwUwhktrfnAt7J++jwQtLZcm3sr9LQrjRzz6cfMv9aLvgmnAGvpoaGLxM4mAEaLV7iAzQ3oU0IvD5x9ix3yF2RAAuYAOO2f7PEFWCXZ4C9Pb2UsgDeVnFSpbFK7/IWu7TPTvBqzbGdCHOJQSxiEjt6IyZmxQyEJHv6xyQsYk//moVFsN2zP6fRImjfq7/n/wFDguUQFNEwugAAAABJRU5ErkJggg==');
  }

  div.callout-important.callout-style-default .callout-title {
    background-color: #f7dddc
  }

  div.callout-warning {
    border-left-color: #f0ad4e !important;
  }

  div.callout-warning .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAETklEQVRYCeVWW2gcVRg+58yaTUnizqbipZeX4uWhBEniBaoUX1Ioze52t7sRq6APio9V9MEaoWlVsFasRq0gltaAPuxms8lu0gcviE/FFOstVbSIxgcv6SU7EZqmdc7v9+9mJtNks51NTUH84ed889/PP+cmxP+d5FIbMJmNbpREu4WUkiTtCicKny0l1pIKmBzovF2S+hIJHX8iEu3hZJ5lNZGqyRrGSIQpq15AzF28jgpeY6yk6GVdrfFqdrD6Iw+QlB8g0YS2g7dyQmXM/IDhBhT0UCiRf59lfqmmDvzRt6kByV/m4JjtzuaujMUM2c5Z2d6JdKrRb3K2q6mA+oYVz8JnDdKPmmNthzkAk/lN63sYPgevrguc72aZX/L9C6x09GYyxBgCX4NlvyGUHOKELlm5rXeR1kchuChJt4SSwyddZRXgvwMGvYo4QSlk3/zkHD8UHxwVJA6zjZZqP8v8kK8OWLnIZtLyCAJagYC4rTGW/9Pqj92N/c+LUaAj27movwbi19tk/whRCIE7Q9vyI6yvRpftAKVTdUjOW40X3h5OXsKCdmFcx0xlLJoSuQngnrJe7Kcjm4OMq9FlC7CMmScQANuNvjfP3PjGXDBaUQmbp296S5L4DrpbrHN1T87ZVEZVCzg1FF0Ft+dKrlLukI+/c9ENo+TvlTDbYFvuKPtQ9+l052rXrgKoWkDAFnvh0wTOmYn8R5f4k/jN/fZiCM1tQx9jQQ4ANhqG4hiL0qIFTGViG9DKB7GYzgubnpofgYRwO+DFjh0Zin2m4b/97EDkXkc+f6xYAPX0KK2I/7fUQuwzuwo/L3AkcjugPNixC8cHf0FyPjWlItmLxWw4Ou9YsQCr5fijMGoD/zpdRy95HRysyXA74MWOnscpO4j2y3HAVisw85hX5+AFBRSHt4ShfLFkIMXTqyKFc46xdzQM6XbAi702a7sy04J0+feReMFKp5q9esYLCqAZYw/k14E/xcLLsFElaornTuJB0svMuJINy8xkIYuL+xPAlWRceH6+HX7THJ0djLUom46zREu7tTkxwmf/FdOZ/sh6Q8qvEAiHpm4PJ4a/doJe0gH1t+aHRgCzOvBvJedEK5OFE5jpm4AGP2a8Dxe3gGJ/pAutug9Gp6he92CsSsWBaEcxGx0FHytmIpuqGkOpldqNYQK8cSoXvd+xLxXADw0kf6UkJNFtdo5MOgaLjiQOQHcn+A6h5NuL2s0qsC2LOM75PcF3yr5STuBSAcGG+meA14K/CI21HcS4LBT6tv0QAh8Dr5l93AhZzG5ZJ4VxAqdZUEl9z7WJ4aN+svMvwHHL21UKTd1mqvChH7/Za5xzXBBKrUcB0TQ+Ulgkfbi/H/YT5EptrGzsEK7tR1B7ln9BBwckYfMiuSqklSznIuoIIOM42MQO+QnduCoFCI0bpkzjCjddHPN/F+2Yu+sd9bKNpVwHhbS3LluK/0zgfwD0xYI5dXuzlQAAAABJRU5ErkJggg==');
  }

  div.callout-warning.callout-style-default .callout-title {
    background-color: #fcefdc
  }

  div.callout-tip {
    border-left-color: #02b875 !important;
  }

  div.callout-tip .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAADr0lEQVRYCe1XTWgTQRj9ZjZV8a9SPIkKgj8I1bMHsUWrqYLVg4Ue6v9BwZOxSYsIerFao7UiUryIqJcqgtpimhbBXoSCVxUFe9CTiogUrUp2Pt+3aUI2u5vdNh4dmMzOzHvvezuz8xNFM0mjnbXaNu1MvFWRXkXEyE6aYOYJpdW4IXuA4r0fo8qqSMDBU0v1HJUgVieAXxzCsdE/YJTdFcVIZQNMyhruOMJKXYFoLfIfIvVIMWdsrd+Rpd86ZmyzzjJmLStqRn0v8lzkb4rVIXvnpScOJuAn2ACC65FkPzEdEy4TPWRLJ2h7z4cArXzzaOdKlbOvKKX25Wl00jSnrwVxAg3o4dRxhO13RBSdNvH0xSARv3adTXbBdTf64IWO2vH0LT+cv4GR1DJt+DUItaQogeBX/chhbTBxEiZ6gftlDNXTrvT7co4ub5A6gp9HIcHvzTa46OS5fBeP87Qm0fQkr4FsYgVQ7Qg+ZayaDg9jhg1GkWj8RG6lkeSacrrHgDaxdoBiZPg+NXV/KifMuB6//JmYH4CntVEHy/keA6x4h4CU5oFy8GzrBS18cLJMXcljAKB6INjWsRcuZBWVaS3GDrqB7rdapVIeA+isQ57Eev9eCqzqOa81CY05VLd6SamW2wA2H3SiTbnbSxmzfp7WtKZkqy4mdyAlGx7ennghYf8voqp9cLSgKdqNfa6RdRsAAkPwRuJZNbpByn+RrJi1RXTwdi8RQF6ymDwGMAtZ6TVE+4uoKh+MYkcLsT0Hk8eAienbiGdjJHZTpmNjlbFJNKDVAp2fJlYju6IreQxQ08UJDNYdoLSl6AadO+fFuCQqVMB1NJwPm69T04Wv5WhfcWyfXQB+wXRs1pt+nCknRa0LVzSA/2B+a9+zQJadb7IyyV24YAxKp2Jqs3emZTuNnKxsah+uabKbMk7CbTgJx/zIgQYErIeTKRQ9yD9wxVof5YolPHqaWo7TD6tJlh7jQnK5z2n3+fGdggIOx2kaa2YI9QWarc5Ce1ipNWMKeSG4DysFF52KBmTNMmn5HqCFkwy34rDg05gDwgH3bBi+sgFhN/e8QvRn8kbamCOhgrZ9GJhFDgfcMHzFb6BAtjKpFhzTjwv1KCVuxHvCbsSiEz4CANnj84cwHdFXAbAOJ4LTSAawGWFn5tDhLMYz6nWeU2wJfIhmIJBefcd/A5FWQWGgrWzyORZ3Q6HuV+Jf0Bj+BTX69fm1zWgK7By1YTXchFDORywnfQ7GpzOo6S+qECrsx2ifVQAAAABJRU5ErkJggg==');
  }

  div.callout-tip.callout-style-default .callout-title {
    background-color: #ccf1e3
  }

  div.callout-caution {
    border-left-color: #fd7e14 !important;
  }

  div.callout-caution .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAACV0lEQVRYCdVWzWoUQRCuqp2ICBLJXgITZL1EfQDBW/bkzUMUD7klD+ATSHBEfAIfQO+iXsWDxJsHL96EHAwhgzlkg8nBg25XWb0zIb0zs9muYYWkoKeru+vn664fBqElyZNuyh167NXJ8Ut8McjbmEraKHkd7uAnAFku+VWdb3reSmRV8PKSLfZ0Gjn3a6Xlcq9YGb6tADjn+lUfTXtVmaZ1KwBIvFI11rRXlWlatwIAAv2asaa9mlB9wwygiDX26qaw1yYPzFXg2N1GgG0FMF8Oj+VIx7E/03lHx8UhvYyNZLN7BwSPgekXXLribw7w5/c8EF+DBK5idvDVYtEEwMeYefjjLAdEyQ3M9nfOkgnPTEkYU+sxMq0BxNR6jExrAI31H1rzvLEfRIdgcv1XEdj6QTQAS2wtstEALLG1yEZ3QhH6oDX7ExBSFEkFINXH98NTrme5IOaaA7kIfiu2L8A3qhH9zRbukdCqdsA98TdElyeMe5BI8Rs2xHRIsoTSSVFfCFCWGPn9XHb4cdobRIWABNf0add9jakDjQJpJ1bTXOJXnnRXHRf+dNL1ZV1MBRCXhMbaHqGI1JkKIL7+i8uffuP6wVQAzO7+qVEbF6NbS0LJureYcWXUUhH66nLR5rYmva+2tjRFtojkM2aD76HEGAD3tPtKM309FJg5j/K682ywcWJ3PASCcycH/22u+Bh7Aa0ehM2Fu4z0SAE81HF9RkB21c5bEn4Dzw+/qNOyXr3DCTQDMBOdhi4nAgiFDGCinIa2owCEChUwD8qzd03PG+qdW/4fDzjUMcE1ZpIAAAAASUVORK5CYII=');
  }

  div.callout-caution.callout-style-default .callout-title {
    background-color: #ffe5d0
  }

  </style>
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
  

    <link rel="icon" href="../Intro2SL_logo.jpg" type="image/jpg"> 

    <link rel="shortcut icon" href="../Intro2SL_logo.jpg" type="image/jpg">

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700" rel="stylesheet" type="text/css">

  </head>

<body class="quarto-light">
  <div class="reveal">
    <div class="slides">


<section id="section" class="slide level2 logo-slide">
<h2></h2>
</section>
<section id="introduction-to-statistical-learning" class="slide level2 title-slide center">
<h2>Introduction to Statistical Learning</h2>
<h3 id="model-selection---part-a---class-5">Model Selection - Part A - Class 5</h3>
<h3 id="giora-simchoni">Giora Simchoni</h3>
<h4 id="gsimchonigmail.com-and-add-intro2sl-in-subject"><code>gsimchoni@gmail.com</code> and add <code>#intro2sl</code> in subject</h4>
<h3 id="stat.-and-or-department-tau">Stat. and OR Department, TAU</h3>
</section>
<section id="expected-prediction-error" class="slide level2 title-slide center">
<h2>Expected Prediction Error</h2>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>עד כאן בקורס, הבנו מה המטרה של למידה סטטיסטית, ראינו את הדוגמא הקלאסית ביותר שהיא המודל הליניארי, אבל חסרה לנו תשובה מעמיקה לשאלה ממש פשוטה: איך אנחנו בוחרים בין מודלים, ואיך נכון לאמוד את הביצועים של מודל סופי. אמנם קיבלנו תחושה כבר שלא נכון להשתמש באותו סט של נתונים לאימון המודל, לבחירה של המודל, להערכה של המודל. אבל בשיעור הזה נפרמל את התחושה הזאת ונדבר לעומק על מספר דרכים שונות לבחור בין מודלים.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="previously-with-the-bias-variance-tradeoff">Previously with the Bias-Variance Tradeoff</h3>
<ul>
<li><p>For regression, take the standard model: <span class="math inline">\(y = f(x) + \varepsilon\;,\;\varepsilon \sim (0,\sigma^2)\)</span></p></li>
<li><p>Modeling approach (e.g.&nbsp;OLS), given training data <span class="math inline">\(T\)</span>, gives model <span class="math inline">\(\hat{f}(x)\)</span></p></li>
</ul>
<div class="fragment">
<ul>
<li>Assume we want to predict at new point <span class="math inline">\(x_0\)</span>, and understand our expected (squared) prediction error: <span class="math display">\[\mathbb{E}_{y_0, T}(y_0 - \hat{f}(x_0))^2 = \text{irreducible error} + \text{squared bias} + \text{variance}\]</span></li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>כדי להגדיר את הקריטריון שלנו אנחנו צריכים להיות מדויקים. מה מבחינתנו נשאר קבוע, מה משתנה מקרי. כי מסתבר שיש יותר מקריטריון אחד.</p>
<p>נתחיל במודל רגרסיה פשוט שבו עסקנו עד כה: Y שווה לאיזושהי פונקציה F של X ועוד רעש מקרי אפסילון, שמתפלג לאו דווקא נורמלית, עם תוחלת אפס ושונות סיגמא בריבוע. אמרנו שאנחנו מקבלים מדגם T בגודל n תצפיות, ומעוניינים לאמוד את F.</p>
<p>ואז פיתחנו את פירוק הביאס-וריאנס, ראינו שעבור תצפית חדשה עם X0 נתון, ואנחנו עושים תוחלת על כל השאר, על-פני מדגם הלמידה שראינו ועל פני הY0 של התצפית החדשה, ההפסד הריבועי מתפרק לטעות אירדוסיבל, היא הסיגמא בריבוע, רעש בסיסי שהמודל שלנו לא מצליח למדל, ועוד הטייה בריבוע, טעות קירוב שנובעת מאופי המודל שלנו, אם נניח שF היא פונקציה מורכבת, אז מודל מורכב יוכל לתאר אותה עם הטיה קטנה, ולמודל פשטני או פשוט לא נכון תהיה הטיה גדולה. וטעות אחרונות של שונות, שנובעת מהתוחלת על-פני הרבה מדגמי למידה, אם נראה מדגם למידה קצת שונה, האם המודל ייראה אחרת לגמרי או שהוא יציב.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="expected-prediction-error-1">Expected Prediction Error</h3>
<p><span class="math display">\[\mathbb{E}_{y_0, T}(y_0 - \hat{f}(x_0))^2 = \text{irreducible error} + \text{squared bias} + \text{variance}\]</span></p>
<div>
<ul>
<li class="fragment">Note we treat both the training data <span class="math inline">\(T\)</span> (and hence <span class="math inline">\(\hat{f}\)</span>) and the response <span class="math inline">\(y_0\)</span> as random variables in our expectations</li>
<li class="fragment">So, more generally we decomposed: <span class="math inline">\(\mathbb{E}_{y_0, T}(L(y_0, \hat{f}(x_0))|X = x_0)\)</span></li>
<li class="fragment"><span style="color:red;">Expected prediction error</span> is when we average over all <span class="math inline">\(x_0\)</span>: <span class="math display">\[Err = \mathbb{E}_{x_0, y_0, T}(L(y_0, \hat{f}(x_0))) = \mathbb{E}_{X}\left[\mathbb{E}_{y_0, T}(L(y_0, \hat{f}(x_0))|X = x_0)\right]\]</span></li>
<li class="fragment">This could also be written as: <span class="math display">\[Err = \mathbb{E}_{x_0, y_0, T}(L(y_0, \hat{f}(x_0))) = \mathbb{E}_{T}\left[\mathbb{E}_{x_0, y_0}(L(y_0, \hat{f}(x_0))|T)\right] = \mathbb{E}\left[Err_T\right]\]</span></li>
<li class="fragment">Some would say the <em>conditional</em> <span class="math inline">\(Err_T\)</span> is even more interesting!</li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>אז כאן אנחנו מתייחסים למדגם הלמידה שלנו כמשתנה מקרי ולY0 כמשתנה מקרי, אבל לX0 כנתון. כלומר אנחנו מפרקים את הטעות הריבועית אם נראה כל מיני מדגמי למידה אחרים וכל מיני ערכי Y0 אחרים לתצפית הX0 הנתונה הזאת.</p>
<p>באופן יותר כללי נרשום זאת כך, עבור איזשהו הפסד L, הסתכלנו על תוחלת מותנית, תוחלת ההפסד ביחס לT ו-Y0 בהינתן X0.</p>
<p>אבל באופן אינטואיטיבי, רבים היו מגדירים את הטעות שהם מעוניינים בה, כתוחלת שולית, על הכל, כלומר גם על המדגם שראינו, וגם על תצפיות חדשות. או במילים אחרות תוחלת של X על התוחלת המותנית שהסתכלנו עליה. נסמן את התוחלת הזאת בErr, ונקרא לה האקספקטד פרדיקשן ארור. שמות אחרים יכולים להיות ג’נ’רליזיישן ארור, טעות ההכללה או האקספקטד טסט ארור.</p>
<p>אפשר לרשום את הטעות הזאת, את התוחלת הזאת כתוחלת שלמה של תוחלת מותנית אחרת: התוחלת המותנית בהינתן מדגם הלמידה, הזוגות של X ו-Y שמהם למדנו. ואז התוחלת היא רק על תצפיות חדשות X0 וY0. והטעות שלנו היא התוחלת על-פני כל מדגמי הלמידה. נסמן את התוחלת המותנית החדשה כErrT, ואם נחשוב עליה קצת - אולי היא זאת שבכלל מעניין אותנו לאמוד! הרי במציאות אני לא מקבל עוד ועוד מדגמי למידה ומעניין אותי איך מבצע המודל שלי על פני הרבה מדגמי למידה. לא! אני מקבל מדגם למידה אחד ובהנחה שהמדגם שלי טוב, כלומר מייצג, ואין שיפט בדאטא שהמודל ייבחן עליו, מעניין אותי לדעת את הביצועים של המודל בהינתן המדגם הזה, לכל תצפית חדשה שתבוא.</p>
<p>זאת באמת טעות שמעניין להעריך אבל קשה להעריך אותה. בפועל נראה שהרבה יותר קל לאמוד את הטעות דווקא השולית, תוחלת ההפסד על פני הרבה מדגמי למידה והרבה תצפיות חדשות.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="what-epe-is-for">What EPE is for?</h3>
<div class="fragment">
<ol type="1">
<li><span style="color:red;">Model Selection</span>: select between a set of models (e.g.&nbsp;one with 5 parameters and the other with 6 parameters) the one with lowest prediction error</li>
<li><span style="color:red;">Model Assessment</span>: know how accurate the model would be, estimate the prediction error itself</li>
</ol>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>בשלב הזה ראוי להפריד בין שתי מטרות ראויות:</p>
<p>האחת היא מודל סלקשן, אני רוצה לבחור מתוך סט של מודלים נאמדים את הטוב ביותר, עם המינימום תוחלת הפסד החיזוי. לדוגמא במודל הליניארי לבחור בין מודל עם 5 משתנים או 6.</p>
<p>ומטרה אחרת היא לקחת מודל סופי שנבחר, ולאמוד באמצעותו את תוחלת הפסד החיזוי עצמה, את הביצועים של המודל הסופי שנבחר. מטרה זו נקראת מודל אססמנט או אבליואיישן.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="how-to-estimate-epe">How to estimate EPE?</h3>
<div class="fragment">
<div class="callout callout-note callout-style-simple">
<div class="callout-body">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-content">
<p>What do you mean how, why not training error: <span class="math display">\[\overline{err} = \frac{1}{n}\sum_{i=1}^{n} L(y_i, \hat{f}(x_i))\]</span></p>
</div>
</div>
</div>
</div>
<div>
<ol type="1">
<li class="fragment">Data splitting: Train-Validation-Test</li>
<li class="fragment">Cross Validation</li>
<li class="fragment">The Bootstrap</li>
<li class="fragment">Training error + Optimism</li>
</ol>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>ושוב נזכיר - מה, אי אפשר לאמוד את תוחלת ההפסד עם ההפסד של מדגם הלמידה? אנחנו נסמן אותו כerr עם קו מעל. התשובה צריכה כבר להיות ברורה לכולם: מאוד מאוד לא נכון לאמוד את השגיאה של מודל על תצפיות שהוא לא למד עליהן, מתצפיות שהוא כן למד עליהן. השגיאה הזאת אופטימית מדי. אם נרצה לבחור למשל את המודל הטוב ביותר לפי המודל שמביא את שגיאת הטריין למינימום, רוב הסיכויים שנבחר במודל מורכב מדי שלא לצורך, שעושה אוברפטינג למדגם הלמידה, מתחיל למדל את האירדוסיבל ארור ולא יכליל טוב כשיגיעו תצפיות חדשות.</p>
<p>אז ניכנס לעומק של ארבע אופציות טובות יותר:</p>
<p>ברמה הבסיסית ביותר יש לנו את האופציה של חלוקה יחידה של הדאטא שלנו לטריין, ולידיישן וטסט.</p>
<p>גירסה קצת יותר יעילה של חלוקה כזאת היא חלוקה של הדאטא לכמה פולדים, מה שנקרא קרוס-ולידיישן.</p>
<p>נדבר גם על הבוטסטרפ, ובסופו של דבר גם על גישה מסורתית יותר שמתאימה במיוחד למדגמים קטנים, שבה אנחנו פשוט מנסים לאמוד עד כמה מדגם הלמידה אופטימי, ולהוסיף את התיקון הזה לטריינינג לוס.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="data-splitting" class="slide level2 title-slide center">
<h2>Data splitting</h2>
<aside class="notes">
<div style="direction:rtl; font-size:16px">

</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="data-splitting-train-validation-test">Data splitting: Train-Validation-Test</h3>
<div id="8c62a33d" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c05_model_selectionA_files/figure-revealjs/cell-2-output-1.png" width="763" height="167"></p>
</figure>
</div>
</div>
</div>
<p>Divide the given sample to 3:</p>
<ul>
<li><span style="color:red;">Training set</span>: learn different models</li>
<li><span style="color:red;">Validation set</span>: decide on final model (model selection, tuning)</li>
<li><span style="color:red;">Test set</span>: estimate final model’s performance (model assessment)</li>
</ul>
<div class="fragment">
<div class="callout callout-note callout-style-simple">
<div class="callout-body">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-content">
<p>Why not use the final model’s performance on <em>validation</em> set as estimate?</p>
</div>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>נתחיל בגישה המתבקשת: לפצל את הדאטא שלנו, לעשות לו ספליטינג.</p>
<p>הגישה הקלאסית אומרת לפצל אותו ל3: טריינינג, ולידיישן וטסט. אין המלצה אחידה שמתאימה לכל דאטא, כמה אחוזים לשים בכל ספליט. כאן אנחנו רואים חלוקה סבירה של 60 אחוז לטריינינג, 20 אחוז לולידיישן ו20 אחוז לטסט.</p>
<p>והפרוצדורה היא כזאת: נאמן את כל המודלים המועמדים על הטריינינג דאטא. נבחן את הביצועים שלהם על הולידיישן דאטא ונבחר את המודל הטוב ביותר לפי זה שמביא את השגיאה של הולידיישן למינימום. זה המודל סלקשן, או טיונינג, כוונון של איזשהו פרמטר לא ידוע במודל. לבסוף, כדי לבצע מודל אססמנט, לאמוד את תוחלת הפסד החיזוי או הביצועים של המודל, ניגש לסט הטסט של נתונים ששמרנו בצד.</p>
<p>בשלב הזה מתבקשת השאלה - למה אנחנו צריכים עוד סט של נתונים כדי לאמוד את השגיאה הסופית של המודל? כרגע הרצנו אותו על הולידיישן סט, אי אפשר להשתמש בשגיאה הזאת כאומד לביצועים של המודל על דאטא שהוא לא ראה? התשובה היא שלא, זה בעייתי. כבר השתמשנו בשגיאה הזאת כדי לקבוע מי המודל עם הביצועים הטובים ביותר. אנחנו לא יכולים להשתמש בה גם לאמוד את שגיאת החיזוי עצמה, כי אנחנו כבר יודעים שאנחנו מסתכלים על השגיאה הכי קטנה. מבחינה מתמטית, אם השגיאת ולידיישן של מודל 1 אומד חסר הטיה לתוחלת השגיאה של מודל 1, והשגיאת ולידיישן של מודל 2 אומד חסר הטיה לתוחלת השגיאה של מודל 2, הפרש השגיאות ולידיישן הוא אומד טוב להפרש התוחלות כלומר לקבוע מי המודל הטוב יותר. אבל המינימום מביניהן הוא לא אומד חסר הטיה למינימום התוחלות.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="data-splitting-comments">Data splitting: comments</h3>
<div>
<ul>
<li class="fragment">Test set is used only once!</li>
<li class="fragment">Since larger <span class="math inline">\(n\)</span> should improve model’s performance, after model selection:
<ul>
<li class="fragment">unite {training + validation}, train final model and then assess it on the test set</li>
</ul></li>
<li class="fragment">No clear guidelines: 60-20-20%, 50-25-25%, … (depends on <span class="math inline">\(n\)</span> and nature of <span class="math inline">\(f\)</span>)</li>
<li class="fragment">Disadvantages:
<ul>
<li class="fragment">Lose half the data? Only if we are rich in data</li>
<li class="fragment">Model assessment highly variable</li>
</ul></li>
<li class="fragment">Additional assumption rarely mentioned</li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>כמה הערות:</p>
<p>הטסט סט בשימוש רק פעם אחת! חוקר טוב צריך להיות כן עם עצמו ובשביל אמידת שגיאת החיזוי הסופית צריך להשתמש בדאטא טרי באמת.</p>
<p>הערה נוספת: מקובל אחרי בחירת המודל הסופי לאחד את כל הדאטא שיש לנו, ה60 אחוז של הטריינינג וה20 אחוז של ולידיישן כדי לאמן את המודל פעם נוספת, ואת המודל הזה להעריך על הטסט סט פעם אחרונה.</p>
<p>כאמור, אין הוראה ברורה כמה אחוזים בדיוק לתקצב כל אחד מהספליטים, זה תלוי בגודל המדגם הנתון ובמורכבות היחס F בין X לY שאנחנו מנסים להעריך. אם הוא פשוט סביר שלא צריך המון דאטא לאמן אותו, ואם הוא מורכב צריך כמה שיותר מהדאטא לאמן אותו.</p>
<p>אז זאת הגישה הקלאסית, אבל יש לה שתי בעיות עיקריות: אחת, היא אנחנו מאמנים את כל המודלים המועמדים על 50-60 אחוז מהתצפיות, זה שימוש לא יעיל בנתונים שאפשרי רק אם יש לנו הרבה מהם.</p>
<p>והבעיה השניה היא שאמנם האומד לשגיאת החיזוי חסר הטיה אבל יש לו שונות גבוהה, אנחנו מבססים את האמידה שלנו בכל זאת על סט נתונים אחד ויחיד, אפילו שהוא נדגם מקרית, ובמיוחד עם מודלים מודרנים של למידה סטטיסטית, לא מסוגלים לתת שום אומד לשגיאה, לאיזו סטיית תקן לאומד הסופי הזה של ביצועי המודל.</p>
<p>והערה אחרונה שלא מדוברת הרבה, ונרחיב עליה יותר עוד שני שיעורים: התוצאה על ה test היא אומד בלתי מוטה לביצועי המודל בעולם האמיתי. אבל כדי שזה יהיה נכון, אנחנו חייבים להניח שהעולם שממנו למדנו אינו משתנה עם הזמן או ליתר דיוק שהתפלגות המדגם שניתן לנו מתאימה להתפלגות העולם.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="single-split-need-2nd-opinion">Single split: need 2nd opinion</h3>
<div id="bbc00d85" class="cell" data-execution_count="2">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c05_model_selectionA_files/figure-revealjs/cell-3-output-1.png" width="1142" height="470"></p>
</figure>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>כאן אנחנו מדגימים את הבעייתיות של סינגל ספליט עם רגרסיה פולינימיאלית, שבה אנחנו מתאימים את Y כפונקציה פולינומיאלית של X, ומתלבטים בדרגת הפולינום הנכונה. מצד שמאל אפשר לראות את הMSE של המודל כתלות בדרגת הפולינום על ולידיישן סט שהמודל לא אומן עליו. מצד ימין אפשר לראות את אותו תרגיל על עשרה ולידיישן סט מקריים כולל את זה שלנו בכחול. יכול להיות שכולם יגיעו לאותה מסקנה מבחינת מודל סלקשן, שהדרגה שמביאה למינימום שגיאה ריבועית היא 3. אבל מבחינת מודל אססמנט, מה הMSE שצפוי לנו על נתונים שהמודל לא ראה, אפשר לראות שונות גדולה מאוד, אם אנחנו מסתכלים רק על טסט סט יחיד והוא לא מאוד גדול, אנחנו לא משקפים את זה. יכול להיות שראינו את אחת העקומות הפסימיות או האופטימיות מבין הספליטים האלה.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="cross-validation" class="slide level2 title-slide center">
<h2>Cross Validation</h2>
<aside class="notes">
<div style="direction:rtl; font-size:16px">

</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="k-fold-cross-validation"><span class="math inline">\(K\)</span>-fold Cross Validation</h3>
<div id="12d77a8e" class="cell" data-execution_count="3">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c05_model_selectionA_files/figure-revealjs/cell-4-output-1.png" width="950" height="470"></p>
</figure>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>קרוס ולידיישן היא שיטה פופולרית מאוד כשאין לנו כל-כך הרבה דאטא, וגם כשאנחנו רוצים להימנע מלהסתמך על מדגם יחיד כשאנחנו באים לבצע אססמנט.</p>
<p>עיקר הפרוצדורה מוצג כאן, אנחנו נחלק את הדאטא לK חלקים שווים שנקראים פולדים או קפלים. כאן K שווה 5.</p>
<p>ונאמן כל אחד מהמודלים המועמדים K פעמים. כל פעם נבחר בפולד אחר להיות הולידיישן סט, כשאנחנו מאמנים את המודל על K פחות 1 הפולדים האחרים.</p>
<p>בסופו של דבר נאסוף את כל השגיאות מכל הn תצפיות כאשר הן שימשו כולידיישן. ומכאן מגיעה היעילות, השגיאה שאנחנו מדווחים היא מ100 אחוז מהמדגם!</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="k-fold-cross-validation-1"><span class="math inline">\(K\)</span>-fold Cross Validation</h3>
<p>More formally:</p>
<ul>
<li>Define a random partition of the <span class="math inline">\(n\)</span> data points into <span class="math inline">\(K\)</span> sets, each of size <span class="math inline">\(n / K\)</span>: <span class="math display">\[\kappa: \{1,\dots,n\} \to \{1,\dots,K\}\]</span></li>
<li>For <span class="math inline">\(k = 1, \dots, K\)</span> do:
<ul>
<li>Build a model <span class="math inline">\(\hat{f}^{(-k)}\)</span> using all folds except the <span class="math inline">\(k\)</span>-th fold (total <span class="math inline">\(n \cdot (K - 1)/ K\)</span> data points)</li>
<li>Predict on remaining <span class="math inline">\(k\)</span>-th fold: <span class="math inline">\(L_k = \sum_{i \in k\text{th fold}}L(y_i, \hat{f}^{(-k)}(x_i))\)</span></li>
</ul></li>
<li>CV estimate for prediction error: <span class="math inline">\(CV = \frac{1}{n}\sum_{k = 1}^{K} L_k\)</span></li>
</ul>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>בצורה פורמלית יותר נגדיר חלוקה קאפא שממפה כל אחת מn התצפיות לאחד מK הפולדים.</p>
<p>לכל פולד, נאמן את מודל f_hat פחות K, כאשר אנחנו מאמנים על כל הפולדים חוץ מK.</p>
<p>נחזה על הפולד הK שהמודל לא ראה, נקרא לסכום השגיאה על כל התצפיות של הפולד הזה LK.</p>
<p>והשגיאה הסופית שלנו היא איסוף ומיצוע של השגיאה מכל הפולדים, כלומר סכום LK וחלוקה פי n.</p>
<p>נזכיר שפעמים רבות אנחנו רואים גם חישוב קצת אחר, שLK שווה לשגיאה הממוצעת על פני הפולד הK, ואז מדווחים על השגיאה הסופית כממוצע הממוצעים, ואפשר להוסיף לזה גם סטיית תקן או טעות תקן של הממוצע, על פני K הפולדים.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="model-selection-with-cv">Model selection with CV</h3>
<ul>
<li>To perform model selection on tuning parameter <span class="math inline">\(\lambda\)</span>: <span class="math display">\[L_k(\lambda) = \sum_{i \in k\text{th fold}}L(y_i, \hat{f}_{\lambda}^{(-k)}(x_i)), \quad CV(\lambda) = \frac{1}{n}\sum_{k = 1}^{K} L_k, \quad \hat{\lambda} = \arg\min_\lambda CV(\lambda)\]</span></li>
<li>Alternatively use the 1-SE rule (see next slide)</li>
<li>Optionally, train final model using <span class="math inline">\(\hat{\lambda}\)</span> on all <span class="math inline">\(n\)</span> observations and assess it on a fresh test set</li>
</ul>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>כעת, אם אנחנו רוצים לבצע מודל סלקשן, למשל לבחור איזשהו פרמטר למדא של המודל שמביא למינימום שגיאה אפשר לאמן את המודל עבור כמה למדא שונות. ולבחור את הלמדא שמביא למינימום את שגיאת הקרוס ולידיישן.</p>
<p>אם משתמשים בממוצע השגיאה בכל פולד ויש לנו טעות תקן שחישבנו לממוצע הזה על פני K פולדים, סטנדרט ארור, אפשר להשתמש גם בכלל ה1SE, שזה אומר לבחור את הפרמטר למדא שמביא למודל הפשוט ביותר כל עוד השגיאה שלו היא בטווח עד טעות תקן אחת לשגיאה הכי קטנה שהתקבלה. הטענה היא שאסטרטגיה כזאת שלא לבחור את המודל עם השגיאה הכי הכי קטנה אלא המודל הפשוט ביותר שהשגיאה שלו עדיין בתחום סביר, עשויה להקטין את הסיכוי לאוברפיטינג.</p>
<p>מכל מקום, אחרי שבחרנו את המודל הסופי או פרמטר סופי, ואנחנו רוצים לבצע מודל אססמנט. בדיוק מאותן סיבות שהזכרנו, נראה הרבה פעמים איחוד של כל הדאטא, אימון עם הפרמטר או המודל הסופי הנבחר על כל התצפיות, ואמידה של הטעות הסופית הסופית על דאטא שנשאר בצד, כלומר שילוב עם השיטה הקודמת.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="what-does-cv-error-estimate">What does CV error estimate?</h3>
<div id="02615a6c" class="cell" data-execution_count="4">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c05_model_selectionA_files/figure-revealjs/cell-5-output-1.png" width="833" height="429"></p>
</figure>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>לפני שנמשיך, ראינו שיש כל מיני טעויות שניתן להסתכל עליהן, תלוי מה אנחנו מחליטים לקבע ולמה להתייחס כמשתנה מקרי. אז מסתבר שקרוס ולידיישן הוא אומד די טוב לתוחלת הפסד החיזוי שסימנו כErr, כלומר התוחלת השולית על פני הרבה מדגמים מקריים ותצפיות חדשות מקריות. כאן השתמשנו בדוגמא של הרגרסיה הפולינומיאלית ואנחנו יודעים לחשב אנליטית את השגיאה הזאת שאנחנו מנסים לאמוד. הנקודות הכחולות הן ממוצע הMSE על-פני 5 פולדים, והארור בארז הן פלוס מינוס טעות התקן של הממוצע. כאן המינימום מתקבל עבור פולינום מדרגה 4, אבל אם נשתמש בכלל ה1SE, נבחר במודל הפשוט יותר שעדיין מביא לשגיאה בטווח טעות התקן של השגיאה הטובה ביותר, וזה פולינום מדרגה 3. אפשרות אחרת היא אגב לבצע ממש מבחן סטטיסטי על פני הפולדים, לקבוע האם הפולדים בדרגה 3 מביאים בממוצע לשגיאה שונה באופן מובהק סטטיסטית מהפולדים בדרגה 4.</p>
<p>בכל מקרה אנחנו רואים שבמקרה זה שגיאת הקרוס-ולידיישן היא אומד לא רע עבור תוחלת הפסד החיזוי.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="can-k-fold-cv-be-biased">Can <span class="math inline">\(K\)</span>-fold CV be biased?</h3>
<div id="68ab4f14" class="cell" data-execution_count="5">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c05_model_selectionA_files/figure-revealjs/cell-6-output-1.png" width="371" height="376"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>Assume our model requires at least 50 data points to reach its potential</li>
<li>What will happen if we do 5-fold CV on a training set that contains exactly 50 observations?</li>
<li><span class="math inline">\(CV\)</span> error would be biased, over-estimated</li>
</ul>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>בדוגמא שלנו היו מספיק תצפיות כדי ששגיאת הקרוס ולידיישן תהיה אומד טוב לתוחלת הפסד החיזוי לתצפיות שהמודל לא ראה. אבל צריך לזכור שלא נפתרו כל בעיותינו, אם הדאטא קטן ומכיל 50 תצפיות, והמודל שלנו צריך לפחות 50 תצפיות כדי לחזות טוב על תצפיות שלא ראה, ואנחנו עושים קרוס ולידיישן עם 5 פולדים - המודל יראה רק 40 תצפיות כל פעם!</p>
<p>ואפשר לדמיין מין עקומת למידה כזאת, היפותטית, שבה אכן מודל צריך 50 תצפיות כדי “להגשים את הפוטנציאל” שלו, ואנחנו תמיד רואים פחות. במקרה כזה המודל יבצע בממוצע פחות טוב, והשגיאה תהיה מוטה כלפי מעלה. אז צריך לקחת את זה לתשומת ליבנו.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="leave-one-out-cv-loocv">Leave-one-out CV (LOOCV)</h3>
<ul>
<li>So why not <span class="math inline">\(K = n\)</span>?</li>
<li>Train on <span class="math inline">\(n - 1\)</span> observations excluding observation <span class="math inline">\(i\)</span>, test on observation <span class="math inline">\(i\)</span></li>
</ul>
<div>
<ul>
<li class="fragment">Might be computationally intensive (though see Generalized CV (GCV))</li>
<li class="fragment">Test on 1 observations, training sets extremely dependent <span class="math inline">\(\to\)</span> low bias but high variance!</li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>ואם אנחנו כל-כך מודאגים - למה לא לעשות שK שווה לN, כלומר נחלק את הדאטא לN פולדים, כל פעם נאמן על N פחות 1 תצפיות ונבחן את המודל על התצפית שהשמטנו.</p>
<p>אז זה רעיון דווקא מקובל שנקרא ליב-וואן-אאוט קרוס ולידיישן, או LOOCV. באופן כזה אנחנו ממצים את הדאטא בצורה היעילה ביותר, ואנחנו יכולים להיות בטוחים שהשגיאה לא תהיה מוטה, אנחנו משתמשים בכמעט כל הדאטא שברשותנו לאימון ולחיזוי.</p>
<p>אז שתי בעיות: בעיה ראשונה היא שמבחינה חישובית לאמן את המודל n פעמים יכול לקחת המון זמן ומשאבים. אם אנחנו רוצים גם לאמן D מודלים שונים על כל פולד זה אומר D כפול N פעמים לאמן! צריך להגיד שזאת בעיה בעיקר למודלים מודרניים, אם אנחנו מדברים רק על רגרסיה ליניארית, מסתבר שיש לנו קיצור דרך לחשב את השגיאה של ליב-וואן-אאוט, זה נקרא ג’נרלייזד קרוס ולידיישן, אבל לא נפתח את זה כרגע.</p>
<p>בעיה אחרת, גם אם חישובית אנחנו מצליחים להתגבר על המשימה הזאת, היא שכעת המדגמים שעליהם אנחנו מאמנים את המודלים הם מאוד מאוד תלויים, המודלים יראו תמיד את אותן התצפיות! אז השגיאה לא תהיה מוטה, ניצלנו את כל מה שהיה לנו, אבל השונות תהיה גבוהה, כי אנחנו בעצם חוזרים על אותו מודל כמעט N פעמים ולא מרוויחים שום דבר מהמיצוע שלו!</p>
<p>מבחינה מתמטית, אם נסתכל על נקודת הקיצון שאנחנו מאוד קרובים אליה, של כל המודלים זהים עם איזו שונות טאו בריבוע, ואנחנו ממצעים אותם, אנחנו בעצם מקבלים את אותו מודל מקורי עם שונות טאו בריבוע. מתי נרוויח ממיצוע K מודלים? רק אם הם יהיו כמה שיותר שונים זה מזה, בלתי תלויים, ואז שונות הממוצע שלהם תהיה קטנה פי K.</p>
<p>כלומר בשורה התחתונה חזרנו לנקודת ההתחלה, של להיות קרובים לאמן מודל אחד ויחיד, שיכולה להיות לו שונות גבוהה.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="cv---interim-summary">CV - Interim Summary</h3>
<div class="columns">
<div class="column" style="width:33%;">
<p>Single-split:</p>
<ul>
<li><span class="math inline">\(`K = 1`\)</span></li>
<li>Not efficient use of data</li>
<li>Highly variable, “need 2nd opinion”</li>
<li>For large <span class="math inline">\(n\)</span></li>
</ul>
</div><div class="column" style="width:33%;">
<p><span class="math inline">\(K\)</span>-fold CV:</p>
<ul>
<li><span class="math inline">\(K = 5, 10\)</span></li>
<li>More efficient use of data but “Learning Curve”</li>
<li>Can combine with an additional final test set</li>
<li>Can become computationally intensive (2+ tuning params, finer grid)</li>
<li>Probably best compromise</li>
</ul>
</div><div class="column" style="width:33%;">
<p>LOOCV:</p>
<ul>
<li><span class="math inline">\(K = n\)</span></li>
<li>Most efficient use of data, unbiased</li>
<li>But computational intensive for modern ML techniques, even for 1 param</li>
<li>High variance</li>
</ul>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>אז נסכם איפה אנחנו עומדים עד עכשיו עם קרוס ולידיישן:</p>
<p>בקצה האחד שאפשר לקרוא לו K = 1, למרות שזה לא נכון, אנחנו פשוט עושים סינגל ספליט על הנתונים, עם טריינינג סט אחד, ולידיישן סט אחד וטסט סט אחד – זה מתאים למצב שיש לנו הרבה מאוד נתונים כי זו חלוקה לא יעילה של הדאטא. אנחנו מסתמכים גם על חלוקה אחת ויחידה ולכן הטעות הנאמדת הסופית יכולה להיות בעלת שונות גבוהה, היא לא ממוצע של כמה דעות.</p>
<p>בצד השני של הסקאלה K = N, זה השימוש היעיל ביותר בנתונים כי אנחנו מאמנים כל פעם כמעט על כולם ולא תהיה לנו שום הטייה שמקורה בגודל המדגם. אבל חישובית זה עלול להיות מופרך, אפילו אם כל מה שיש לנו לעשות זה לבחור פרמטר אחד, ובשיטות מודרניות יכולים להיות לנו כמה פרמטרים. ואנחנו מרוויחים ממש מעט מהממוצע הזה כי המודלים תלויים מאוד ביניהם מה שמשאיר את השונות של המודל האחד גבוהה.</p>
<p>כנראה שהפשרה היא איפשהו באמצע. אנחנו רואים בפועל שK שווה 5 או 10 עובד די טוב. זה נכון שעבור מעט תצפיות גם זה יכול להיות בעייתי בגלל הלרנינג קרב ואיבוד דאטא בזמן האימון, זה נכון שאם יש לנו הרבה פרמטרים לכוונון גם זה יכול להיעשות עמוס חישובית, אבל זאת פשרה לא רעה בין הקצוות.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="cross-validation---common-pitfalls" class="slide level2 title-slide center">
<h2>Cross Validation - Common Pitfalls</h2>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>קרוס ולידיישן זאת שיטה שנמצאת בשימוש רחב, ויש למשתמשים נטייה גם לבצע אותה לא נכון. נסיים בשתי בעיות שאנחנו רואים הרבה פעמים בשימוש בשיטה.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="cv---common-pitfalls-i">CV - Common Pitfalls (I)</h3>
<ul>
<li>Suppose we have many days of sequential inter-daily data (<span style="color:red;">time series</span>)</li>
<li>We do CV and randomly divide the data into parts</li>
<li>Can we rely on the variance reduction of the parts?</li>
<li>Did we leak information between the training part and the test part?</li>
</ul>
<div>
<ul>
<li class="fragment">No and Yes!</li>
<li class="fragment">we cannot assume the parts are independent, and we probably have an information leak <span class="math inline">\(\to\)</span> we under-estimate the error</li>
<li class="fragment">How can we correct this?</li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>בעיה ראשונה יכולה להיות כשבדאטה יש תלות אינהרנטית בין התצפיות, שלא נלקחת בחשבון בעת החלוקה לפולדים. דוגמא טובה לזה יכולה להיות כשהנתונים שלנו עם טיים סרייז, סדרה עתית, כמו למשל נתונים על פני ימים רבים של מחירי מניות, והמודל שלנו נבנה כדי לחזות את המחיר של מניה מחר.</p>
<p>אם נבצע חלוקה לפולדים בצורה נאיבית כמו לכל דאטא טבלאי:</p>
<p>האם אנחנו יכולים לסמוך על ההפחתה בשונות של האומד למדגם אחד, שאנחנו מצפים לקבל בעקבות חזרה על התהליך על פני כמה פולדים? האם אין לנו זליגת של דאטא כל פעם בין מדגם הלמידה למדגם הולידיישן?</p>
<p>התשובות לשתי השאלות האלה לצערנו הן לא וכן.</p>
<p>יש כאן שתי בעיות: אחת היא תלות בזמן בין ימים, סביר להניח שיש תלות בין תצפיות מימים עוקבים למשל. והתלות הזאת יכולה להמשיך איתנו בחלוקה לפולדים, אנחנו בטוחים שאנחנו מחלקים את הדאטא בצורה מקרית ל5 או 10 מדגמים שונים, אבל בפועל מקבלים תלות בזמן בין מדגמי הלמידה השונים.</p>
<p>בעיה נוספת, במיוחד אם המטרה של מודל כזה היא חיזוי של מה שיקרה בעתיד - אנחנו כרגע גרמנו לו לראות את העתיד! אם בחלוקה לפולדים אנחנו לא מוודאים שפולד הטריינינג תמיד מכיל תצפיות מהעבר שהגיוני שהמודל ראה, ופולד הולידיישן תמיד מכיל תצפיות מהעתיד שהגיוני שהמודל צריך לחזות עליהן – זה בדיוק זליגה של דאטא בין פולדים. בסופו של דבר המודל “חוזה” על העתיד, על תצפיות שהוא התאמן קרוב מאוד אליהן, והשגיאה שלו תהיה מוטה כלפי מטה, הוא יהיה אופטימי מדי.</p>
<p>לכן, צריך מאוד להיזהר בחלוקה לפולדים כשאנחנו יודעים שהתפקיד של המודל לחזות את העתיד של מניה למשל, או לחזות את הקרינה במרחב במיקומים חדשים על סמך קריאות ממיקומים אחרים. צריך לדאוג להיות עקביים ולשלב את המטרה הטבעית הזאת בחלוקה לפולדים, להתאמן על העבר, ולחזות את העתיד, או להתאמן על מיקומים ידועים ולחזות על מיקומים לא ידועים.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="cv---common-pitfalls-ii">CV - Common Pitfalls (II)</h3>
<ul>
<li>Suppose we have a data with many variables, can we do the following process to estimate the prediction error:
<ul>
<li>On all the data find a small subset of the strongest variables</li>
<li>Perform CV using only this set of variables</li>
</ul></li>
</ul>
<div>
<ul>
<li class="fragment">Extremely problematic and overly optimistic!</li>
<li class="fragment">Where is the information leakage?</li>
<li class="fragment">Similar principle: standardizing the data based on all <span class="math inline">\(n\)</span> observations</li>
<li class="fragment">How can we correct this?</li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>בעיה נוספת שאנחנו רואים המון, גם היא ביסודה זליגה או ליקג’ של דאטא של הולידיישן אל הדאטא של הטריין:</p>
<p>נניח שיש לנו נתונים עם המון משתנים. המון משתנים ברמה שהמודל לא יכול להתמודד עם כל כך הרבה, ואנחנו מחלליטים קודם כל לעשות סקרינינג של תת-קבוצה של משתנים לפי איזשהו קריטריון, למשל אלה המשתנים שבאופן שולי בעלי הקורלציה הגבוהה ביותר למשתנה התלוי Y – ורק עכשיו! להתחיל תהליך של קורס ולידיישן על המשתנים הנותרים – יכול להיות שזה בעייתי?</p>
<p>זה יכול להיות בעייתי מאוד. להחליט החלטות בייסליין כאלה על פני כל המדגם. איפה כאן הדאטא ליקג’? בעובדה שהמודל כבר יודע משהו על התצפיות שתיכף יוגדרו כתצפיות ולידיישן! הוא כבר נחשף אליהן, הוא כבר ביצע החלטה על סמך התצפיות האלה! בעוד שב”חיים האמיתיים” של מודל כזה, לא תהיה לו האפשרות להציץ בתצפיות שהוא עומד לקבל, הוא לא יכול לסמוך על מידע שיש בהן בשום אופן כדי שנקבל אמידה טובה לביצועים שלו.</p>
<p>דוגמא נוספת שאנחנו רואים זה לעשות סטנדרטיזציה של הדאטא, כלומר לחסר את הממוצע מכל העמודות ולחלק בסטיית התקן, ולעשות את זה על סמך כל הN תצפיות שברשותנו, ורק אז להתחיל תהליך של קרוס ולידיישן. בעייתי מאותה סיבה בדיוק, הממוצעים וסטיות התקן האלה כבר חושבו על סמך התצפיות שבטסט, המודל מכיר אותן ועלול לתת שגיאה אופטימית מדי, מוטה כלפי מטה.</p>
<p>איך מתקנים את זה? צריך לכלול את כל הצעדים הבעייתיים האלה בתהליך הקרוס ולידיישן. אם לדוגמא אנחנו חייבים לעשות סקרינינג של משתנים רלוונטים מתוך הרבה משתנים, זה חייב להיות שלב ראשון שאנחנו מבצעים בתוך הקרוס ולידיישן, לכל אחד ממדגמי הלמידה, אחרי שהשמטנו את מדגם הולידיישן. כלומר הקרוס ולידיישן חייב “לבדוק” עבורנו גם את הצעד הזה. יכול להיות שבמדגם למידה אחד ייבחרו 10 משתנים מסוימים ובמדגם למידה אחר ייבחרו 11 משתנים קצת אחרים וזה בסדר! כי זה רעש מקרי שחייבים לקחת בחשבון בתהליך הלמידה.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="use-pipelines">Use <code>Pipeline</code>s</h3>
<div id="f3e9a24e" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> KFold, GridSearchCV</span>
<span id="cb1-2"><a href="" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> Pipeline</span>
<span id="cb1-3"><a href="" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="" aria-hidden="true" tabindex="-1"></a>kf <span class="op">=</span> KFold(n_splits<span class="op">=</span><span class="dv">5</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb1-5"><a href="" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="" aria-hidden="true" tabindex="-1"></a>pipeline <span class="op">=</span> Pipeline([</span>
<span id="cb1-7"><a href="" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'scaler'</span>, StandardScaler()),</span>
<span id="cb1-8"><a href="" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'feature_selection'</span>, SelectKBest(score_func<span class="op">=</span>f_regression)),</span>
<span id="cb1-9"><a href="" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'knn'</span>, KNeighborsRegressor())</span>
<span id="cb1-10"><a href="" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb1-11"><a href="" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="" aria-hidden="true" tabindex="-1"></a>param_grid <span class="op">=</span> {</span>
<span id="cb1-13"><a href="" aria-hidden="true" tabindex="-1"></a>    <span class="st">'feature_selection__k'</span>: <span class="bu">range</span>(<span class="dv">1</span>, n_features <span class="op">+</span> <span class="dv">1</span>),</span>
<span id="cb1-14"><a href="" aria-hidden="true" tabindex="-1"></a>    <span class="st">'knn__n_neighbors'</span>: [<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">9</span>],</span>
<span id="cb1-15"><a href="" aria-hidden="true" tabindex="-1"></a>    <span class="st">'knn__metric'</span>: [<span class="st">'euclidean'</span>, <span class="st">'manhattan'</span>]</span>
<span id="cb1-16"><a href="" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-17"><a href="" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="" aria-hidden="true" tabindex="-1"></a>grid_search <span class="op">=</span> GridSearchCV(pipeline, param_grid, cv<span class="op">=</span>kf, scoring<span class="op">=</span><span class="st">'neg_mean_squared_error'</span>)</span>
<span id="cb1-19"><a href="" aria-hidden="true" tabindex="-1"></a>grid_search.fit(X, y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>מבחינה מעשית, כל תוכנה רצינית שאיתה מריצים מודלים חייבת לכלול איזשהו קונספט של פייפליין, או “מתכון” שאפשר להגדיר, והוא יהיה מורכב מכמה תת-צעדים שכוללים לא רק את ריצת המודל עצמו. ועל הפייפליין הזה נריץ קרוס ולידיישן, לא רק על ריצת המודל עצמו.</p>
<p>כאן לדוגמא אני משתמש בקלאס פייפליין של sklearn. אני מגדיר שהמתכון הזה יהיה מורכב מ3 צעדים: סטנדרטיזציה של המשתנים, בחירה של סאבסט של משתנים, ורק אז שיטה לרגרסיה כמו KNN. אני מגדיר מהו הגריד של פרמטרים שונים שאני רוצים לבחור מתוכו, לדוגמא כאן מהו הK משתנים שאני רוצה לבחור מתוך הP שיש ברשותי, מהו מספר השכנים של KNN ובאיזו מטריקה KNN ישתמש.</p>
<p>ואז אני משתמש בקלאס שנקרא GridSearchCV שמחפש על כל הקומבינציות של ה3 פרמטרים שחשובים לי, מריץ מודל עם כל קומבינציה באמצעות קרוס-ולידיישן עם 5 פולדים. אבל הכי חשוב, כשאני קורא למתודה פיט, הכוונה לפיט על כל הפייפליין הזה, כולל סטנדרטיזציה, וכולל בחירה של סאבסט של משתנים. לא רק ריצה של KNN עצמו. בדרך הזאת אני מוודא שאין לי זליגה של דאטא מהולידיישן סט לתוך הטריינינג והקרוס ולידיישן אכן מודד את התהליך שאני הייתי רוצה לראות על כל הדאטא.</p>
<p>עד כאן במודל סלקשן, בחלק השני נדבר על שתי השיטות שנותרו לנו - הבוטסטרפ, שמזכירה קצת את הקרוס-ולידיישן במובן של אימון על פני מספר מדגמים שונים מהדאטא. והשיטה של תיקון שגיאת הטריינינג שהיא נמוכה בדרך כלל ממה שאנחנו רוצים, באמצעות איזשהו אומד לעד כמה היא נמוכה, או אופטימית.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
<div class="quarto-auto-generated-content">
<p><img src="../Intro2SL_logo_white.jpg" class="slide-logo"></p>
<div class="footer footer-default">
<p><a href="https://intro2statlearn.github.io/mooc/" target="_blank">Intro to Statistical Learning</a></p>
</div>
</div>
</section>
    </div>
  </div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="../libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="../libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="../libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="../libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="../libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="../libs/revealjs/plugin/reveal-chalkboard/plugin.js"></script>
  <script src="../libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="../libs/revealjs/plugin/notes/notes.js"></script>
  <script src="../libs/revealjs/plugin/search/search.js"></script>
  <script src="../libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="../libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': false,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleChalkboard(event)\"><kbd>b</kbd> Toggle Chalkboard</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleNotesCanvas(event)\"><kbd>c</kbd> Toggle Notes Canvas</a></li>\n<li class=\"slide-tool-item\" data-item=\"6\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.downloadDrawings(event)\"><kbd>d</kbd> Download Drawings</a></li>\n<li class=\"slide-tool-item\" data-item=\"7\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'chalkboard': {"buttons":true},
'smaller': true,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'none',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1050,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        math: {
          mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, RevealChalkboard, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script id="quarto-html-after-body" type="application/javascript">
    window.document.addEventListener("DOMContentLoaded", function (event) {
      const toggleBodyColorMode = (bsSheetEl) => {
        const mode = bsSheetEl.getAttribute("data-mode");
        const bodyEl = window.document.querySelector("body");
        if (mode === "dark") {
          bodyEl.classList.add("quarto-dark");
          bodyEl.classList.remove("quarto-light");
        } else {
          bodyEl.classList.add("quarto-light");
          bodyEl.classList.remove("quarto-dark");
        }
      }
      const toggleBodyColorPrimary = () => {
        const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
        if (bsSheetEl) {
          toggleBodyColorMode(bsSheetEl);
        }
      }
      toggleBodyColorPrimary();  
      const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
      tabsets.forEach(function(tabset) {
        const tabby = new Tabby('#' + tabset.id);
      });
      const isCodeAnnotation = (el) => {
        for (const clz of el.classList) {
          if (clz.startsWith('code-annotation-')) {                     
            return true;
          }
        }
        return false;
      }
      const clipboard = new window.ClipboardJS('.code-copy-button', {
        text: function(trigger) {
          const codeEl = trigger.previousElementSibling.cloneNode(true);
          for (const childEl of codeEl.children) {
            if (isCodeAnnotation(childEl)) {
              childEl.remove();
            }
          }
          return codeEl.innerText;
        }
      });
      clipboard.on('success', function(e) {
        // button target
        const button = e.trigger;
        // don't keep focus
        button.blur();
        // flash "checked"
        button.classList.add('code-copy-button-checked');
        var currentTitle = button.getAttribute("title");
        button.setAttribute("title", "Copied!");
        let tooltip;
        if (window.bootstrap) {
          button.setAttribute("data-bs-toggle", "tooltip");
          button.setAttribute("data-bs-placement", "left");
          button.setAttribute("data-bs-title", "Copied!");
          tooltip = new bootstrap.Tooltip(button, 
            { trigger: "manual", 
              customClass: "code-copy-button-tooltip",
              offset: [0, -8]});
          tooltip.show();    
        }
        setTimeout(function() {
          if (tooltip) {
            tooltip.hide();
            button.removeAttribute("data-bs-title");
            button.removeAttribute("data-bs-toggle");
            button.removeAttribute("data-bs-placement");
          }
          button.setAttribute("title", currentTitle);
          button.classList.remove('code-copy-button-checked');
        }, 1000);
        // clear code selection
        e.clearSelection();
      });
        var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
        var mailtoRegex = new RegExp(/^mailto:/);
          var filterRegex = new RegExp('/' + window.location.host + '/');
        var isInternal = (href) => {
            return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
        }
        // Inspect non-navigation links and adorn them if external
     	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
        for (var i=0; i<links.length; i++) {
          const link = links[i];
          if (!isInternal(link.href)) {
            // undo the damage that might have been done by quarto-nav.js in the case of
            // links that we want to consider external
            if (link.dataset.originalHref !== undefined) {
              link.href = link.dataset.originalHref;
            }
          }
        }
      function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
        const config = {
          allowHTML: true,
          maxWidth: 500,
          delay: 100,
          arrow: false,
          appendTo: function(el) {
              return el.closest('section.slide') || el.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'light-border',
          placement: 'bottom-start',
        };
        if (contentFn) {
          config.content = contentFn;
        }
        if (onTriggerFn) {
          config.onTrigger = onTriggerFn;
        }
        if (onUntriggerFn) {
          config.onUntrigger = onUntriggerFn;
        }
          config['offset'] = [0,0];
          config['maxWidth'] = 700;
        window.tippy(el, config); 
      }
      const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
      for (var i=0; i<noterefs.length; i++) {
        const ref = noterefs[i];
        tippyHover(ref, function() {
          // use id or data attribute instead here
          let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
          try { href = new URL(href).hash; } catch {}
          const id = href.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note) {
            return note.innerHTML;
          } else {
            return "";
          }
        });
      }
      const findCites = (el) => {
        const parentEl = el.parentElement;
        if (parentEl) {
          const cites = parentEl.dataset.cites;
          if (cites) {
            return {
              el,
              cites: cites.split(' ')
            };
          } else {
            return findCites(el.parentElement)
          }
        } else {
          return undefined;
        }
      };
      var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
      for (var i=0; i<bibliorefs.length; i++) {
        const ref = bibliorefs[i];
        const citeInfo = findCites(ref);
        if (citeInfo) {
          tippyHover(citeInfo.el, function() {
            var popup = window.document.createElement('div');
            citeInfo.cites.forEach(function(cite) {
              var citeDiv = window.document.createElement('div');
              citeDiv.classList.add('hanging-indent');
              citeDiv.classList.add('csl-entry');
              var biblioDiv = window.document.getElementById('ref-' + cite);
              if (biblioDiv) {
                citeDiv.innerHTML = biblioDiv.innerHTML;
              }
              popup.appendChild(citeDiv);
            });
            return popup.innerHTML;
          });
        }
      }
    });
    </script>
    

</body></html>