<!DOCTYPE html>
<html lang="en"><head>
<script src="../libs/clipboard/clipboard.min.js"></script>
<script src="../libs/quarto-html/tabby.min.js"></script>
<script src="../libs/quarto-html/popper.min.js"></script>
<script src="../libs/quarto-html/tippy.umd.min.js"></script>
<link href="../libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../libs/quarto-html/light-border.css" rel="stylesheet">
<link href="../libs/quarto-html/quarto-html.min.css" rel="stylesheet" data-mode="light">
<link href="../libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.4.554">

  <title>SVM</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="../libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../libs/revealjs/dist/theme/quarto.css">
  <link rel="stylesheet" href="../slides_quarto.css">
  <link href="../libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="../libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="../libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="../libs/revealjs/plugin/reveal-chalkboard/font-awesome/css/all.css" rel="stylesheet">
  <link href="../libs/revealjs/plugin/reveal-chalkboard/style.css" rel="stylesheet">
  <link href="../libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">

  .callout {
    margin-top: 1em;
    margin-bottom: 1em;  
    border-radius: .25rem;
  }

  .callout.callout-style-simple { 
    padding: 0em 0.5em;
    border-left: solid #acacac .3rem;
    border-right: solid 1px silver;
    border-top: solid 1px silver;
    border-bottom: solid 1px silver;
    display: flex;
  }

  .callout.callout-style-default {
    border-left: solid #acacac .3rem;
    border-right: solid 1px silver;
    border-top: solid 1px silver;
    border-bottom: solid 1px silver;
  }

  .callout .callout-body-container {
    flex-grow: 1;
  }

  .callout.callout-style-simple .callout-body {
    font-size: 1rem;
    font-weight: 400;
  }

  .callout.callout-style-default .callout-body {
    font-size: 0.9rem;
    font-weight: 400;
  }

  .callout.callout-titled.callout-style-simple .callout-body {
    margin-top: 0.2em;
  }

  .callout:not(.callout-titled) .callout-body {
      display: flex;
  }

  .callout:not(.no-icon).callout-titled.callout-style-simple .callout-content {
    padding-left: 1.6em;
  }

  .callout.callout-titled .callout-header {
    padding-top: 0.2em;
    margin-bottom: -0.2em;
  }

  .callout.callout-titled .callout-title  p {
    margin-top: 0.5em;
    margin-bottom: 0.5em;
  }
    
  .callout.callout-titled.callout-style-simple .callout-content  p {
    margin-top: 0;
  }

  .callout.callout-titled.callout-style-default .callout-content  p {
    margin-top: 0.7em;
  }

  .callout.callout-style-simple div.callout-title {
    border-bottom: none;
    font-size: .9rem;
    font-weight: 600;
    opacity: 75%;
  }

  .callout.callout-style-default  div.callout-title {
    border-bottom: none;
    font-weight: 600;
    opacity: 85%;
    font-size: 0.9rem;
    padding-left: 0.5em;
    padding-right: 0.5em;
  }

  .callout.callout-style-default div.callout-content {
    padding-left: 0.5em;
    padding-right: 0.5em;
  }

  .callout.callout-style-simple .callout-icon::before {
    height: 1rem;
    width: 1rem;
    display: inline-block;
    content: "";
    background-repeat: no-repeat;
    background-size: 1rem 1rem;
  }

  .callout.callout-style-default .callout-icon::before {
    height: 0.9rem;
    width: 0.9rem;
    display: inline-block;
    content: "";
    background-repeat: no-repeat;
    background-size: 0.9rem 0.9rem;
  }

  .callout-title {
    display: flex
  }
    
  .callout-icon::before {
    margin-top: 1rem;
    padding-right: .5rem;
  }

  .callout.no-icon::before {
    display: none !important;
  }

  .callout.callout-titled .callout-body > .callout-content > :last-child {
    padding-bottom: 0.5rem;
    margin-bottom: 0;
  }

  .callout.callout-titled .callout-icon::before {
    margin-top: .5rem;
    padding-right: .5rem;
  }

  .callout:not(.callout-titled) .callout-icon::before {
    margin-top: 1rem;
    padding-right: .5rem;
  }

  /* Callout Types */

  div.callout-note {
    border-left-color: #4582ec !important;
  }

  div.callout-note .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAEU0lEQVRYCcVXTWhcVRQ+586kSUMMxkyaElstCto2SIhitS5Ek8xUKV2poatCcVHtUlFQk8mbaaziwpWgglJwVaquitBOfhQXFlqlzSJpFSpIYyXNjBNiTCck7x2/8/LeNDOZxDuEkgOXe++553zfefee+/OYLOXFk3+1LLrRdiO81yNqZ6K9cG0P3MeFaMIQjXssE8Z1JzLO9ls20MBZX7oG8w9GxB0goaPrW5aNMp1yOZIa7Wv6o2ykpLtmAPs/vrG14Z+6d4jpbSKuhdcSyq9wGMPXjonwmESXrriLzFGOdDBLB8Y6MNYBu0dRokSygMA/mrun8MGFN3behm6VVAwg4WR3i6FvYK1T7MHo9BK7ydH+1uurECoouk5MPRyVSBrBHMYwVobG2aOXM07sWrn5qgB60rc6mcwIDJtQrnrEr44kmy+UO9r0u9O5/YbkS9juQckLed3DyW2XV/qWBBB3ptvI8EUY3I9p/67OW+g967TNr3Sotn3IuVlfMLVnsBwH4fsnebJvyGm5GeIUA3jljERmrv49SizPYuq+z7c2H/jlGC+Ghhupn/hcapqmcudB9jwJ/3jvnvu6vu5lVzF1fXyZuZZ7U8nRmVzytvT+H3kilYvH09mLWrQdwFSsFEsxFVs5fK7A0g8gMZjbif4ACpKbjv7gNGaD8bUrlk8x+KRflttr22JEMRUbTUwwDQScyzPgedQHZT0xnx7ujw2jfVfExwYHwOsDTjLdJ2ebmeQIlJ7neo41s/DrsL3kl+W2lWvAga0tR3zueGr6GL78M3ifH0rGXrBC2aAR8uYcIA5gwV8zIE8onoh8u0Fca/ciF7j1uOzEnqcIm59sEXoGc0+z6+H45V1CvAvHcD7THztu669cnp+L0okAeIc6zjbM/24LgGM1gZk7jnRu1aQWoU9sfUOuhrmtaPIO3YY1KLLWZaEO5TKUbMY5zx8W9UJ6elpLwKXbsaZ4EFl7B4bMtDv0iRipKoDQT2sNQI9b1utXFdYisi+wzZ/ri/1m7QfDgEuvgUUEIJPq3DhX/5DWNqIXDOweC2wvIR90Oq3lDpdMIgD2r0dXvGdsEW5H6x6HLRJYU7C69VefO1x8Gde1ZFSJLfWS1jbCnhtOPxmpfv2LXOA2Xk2tvnwKKPFuZ/oRmwBwqRQDcKNeVQkYcOjtWVBuM/JuYw5b6isojIkYxyYAFn5K7ZBF10fea52y8QltAg6jnMqNHFBmGkQ1j+U43HMi2xMar1Nv0zGsf1s8nUsmUtPOOrbFIR8bHFDMB5zL13Gmr/kGlCkUzedTzzmzsaJXhYawnA3UmARpiYj5ooJZiUoxFRtK3X6pgNPv+IZVPcnwbOl6f+aBaO1CNvPW9n9LmCp01nuSaTRF2YxHqZ8DYQT6WsXT+RD6eUztwYLZ8rM+rcPxamv1VQzFUkzFXvkiVrySGQgJNvXHJAxiU3/NwiC03rSf05VBaPtu/Z7/B8Yn/w7eguloAAAAAElFTkSuQmCC');
  }

  div.callout-note.callout-style-default .callout-title {
    background-color: #dae6fb
  }

  div.callout-important {
    border-left-color: #d9534f !important;
  }

  div.callout-important .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAEKklEQVRYCcVXTWhcVRS+575MJym48A+hSRFr00ySRQhURRfd2HYjk2SSTokuBCkU2o0LoSKKraKIBTcuFCoidGFD08nkBzdREbpQ1EDNIv8qSGMFUboImMSZd4/f9zJv8ibJMC8xJQfO3HPPPef7zrvvvnvviIkpC9nsw0UttFunbUhpFzFtarSd6WJkStVMw5xyVqYTvkwfzuf/5FgtkVoB0729j1rjXwThS7Vio+Mo6DNnvLfahoZ+i/o32lULuJ3NNiz7q6+pyAUkJaFF6JwaM2lUJlV0MlnQn5aTRbEu0SEqHUa0A4AdiGuB1kFXRfVyg5d87+Dg4DL6m2TLAub60ilj7A1Ec4odSAc8X95sHh7+ZRPCFo6Fnp7HfU/fBng/hi10CjCnWnJjsxvDNxWw0NfV6Rv5GgP3I3jGWXumdTD/3cbEOP2ZbOZp69yniG3FQ9z1jD7bnBu9Fc2tKGC2q+uAJOQHBDRiZX1x36o7fWBs7J9ownbtO+n0/qWkvW7UPIfc37WgT6ZGR++EOJyeQDSb9UB+DZ1G6DdLDzyS+b/kBCYGsYgJbSQHuThGKRcw5xdeQf8YdNHsc6ePXrlSYMBuSIAFTGAtQo+VuALo4BX83N190NWZWbynBjhOHsmNfFWLeL6v+ynsA58zDvvAC8j5PkbOcXCMg2PZFk3q8MjI7WAG/Dp9AwP7jdGBOOQkAvlFUB+irtm16I1Zw9YBcpGTGXYmk3kQIC/Cds55l+iMI3jqhjAuaoe+am2Jw5GT3Nbz3CkE12NavmzN5+erJW7046n/CH1RO/RVa8lBLozXk9uqykkGAyRXLWlLv5jyp4RFsG5vGVzpDLnIjTWgnRy2Rr+tDKvRc7Y8AyZq10jj8DqXdnIRNtFZb+t/ZRtXcDiVnzpqx8mPcDWxgARUqx0W1QB9MeUZiNrV4qP+Ehc+BpNgATsTX8ozYKL2NtFYAHc84fG7ndxUPr+AR/iQSns7uSUufAymwDOb2+NjK27lEFocm/EE2WpyIy/Hi66MWuMKJn8RvxIcj87IM5Vh9663ziW36kR0HNenXuxmfaD8JC7tfKbrhFr7LiZCrMjrzTeGx+PmkosrkNzW94ObzwocJ7A1HokLolY+AvkTiD/q1H0cN48c5EL8Crkttsa/AXQVDmutfyku0E7jShx49XqV3MFK8IryDhYVbj7Sj2P2eBxwcXoe8T8idsKKPRcnZw1b+slFTubwUwhktrfnAt7J++jwQtLZcm3sr9LQrjRzz6cfMv9aLvgmnAGvpoaGLxM4mAEaLV7iAzQ3oU0IvD5x9ix3yF2RAAuYAOO2f7PEFWCXZ4C9Pb2UsgDeVnFSpbFK7/IWu7TPTvBqzbGdCHOJQSxiEjt6IyZmxQyEJHv6xyQsYk//moVFsN2zP6fRImjfq7/n/wFDguUQFNEwugAAAABJRU5ErkJggg==');
  }

  div.callout-important.callout-style-default .callout-title {
    background-color: #f7dddc
  }

  div.callout-warning {
    border-left-color: #f0ad4e !important;
  }

  div.callout-warning .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAETklEQVRYCeVWW2gcVRg+58yaTUnizqbipZeX4uWhBEniBaoUX1Ioze52t7sRq6APio9V9MEaoWlVsFasRq0gltaAPuxms8lu0gcviE/FFOstVbSIxgcv6SU7EZqmdc7v9+9mJtNks51NTUH84ed889/PP+cmxP+d5FIbMJmNbpREu4WUkiTtCicKny0l1pIKmBzovF2S+hIJHX8iEu3hZJ5lNZGqyRrGSIQpq15AzF28jgpeY6yk6GVdrfFqdrD6Iw+QlB8g0YS2g7dyQmXM/IDhBhT0UCiRf59lfqmmDvzRt6kByV/m4JjtzuaujMUM2c5Z2d6JdKrRb3K2q6mA+oYVz8JnDdKPmmNthzkAk/lN63sYPgevrguc72aZX/L9C6x09GYyxBgCX4NlvyGUHOKELlm5rXeR1kchuChJt4SSwyddZRXgvwMGvYo4QSlk3/zkHD8UHxwVJA6zjZZqP8v8kK8OWLnIZtLyCAJagYC4rTGW/9Pqj92N/c+LUaAj27movwbi19tk/whRCIE7Q9vyI6yvRpftAKVTdUjOW40X3h5OXsKCdmFcx0xlLJoSuQngnrJe7Kcjm4OMq9FlC7CMmScQANuNvjfP3PjGXDBaUQmbp296S5L4DrpbrHN1T87ZVEZVCzg1FF0Ft+dKrlLukI+/c9ENo+TvlTDbYFvuKPtQ9+l052rXrgKoWkDAFnvh0wTOmYn8R5f4k/jN/fZiCM1tQx9jQQ4ANhqG4hiL0qIFTGViG9DKB7GYzgubnpofgYRwO+DFjh0Zin2m4b/97EDkXkc+f6xYAPX0KK2I/7fUQuwzuwo/L3AkcjugPNixC8cHf0FyPjWlItmLxWw4Ou9YsQCr5fijMGoD/zpdRy95HRysyXA74MWOnscpO4j2y3HAVisw85hX5+AFBRSHt4ShfLFkIMXTqyKFc46xdzQM6XbAi702a7sy04J0+feReMFKp5q9esYLCqAZYw/k14E/xcLLsFElaornTuJB0svMuJINy8xkIYuL+xPAlWRceH6+HX7THJ0djLUom46zREu7tTkxwmf/FdOZ/sh6Q8qvEAiHpm4PJ4a/doJe0gH1t+aHRgCzOvBvJedEK5OFE5jpm4AGP2a8Dxe3gGJ/pAutug9Gp6he92CsSsWBaEcxGx0FHytmIpuqGkOpldqNYQK8cSoXvd+xLxXADw0kf6UkJNFtdo5MOgaLjiQOQHcn+A6h5NuL2s0qsC2LOM75PcF3yr5STuBSAcGG+meA14K/CI21HcS4LBT6tv0QAh8Dr5l93AhZzG5ZJ4VxAqdZUEl9z7WJ4aN+svMvwHHL21UKTd1mqvChH7/Za5xzXBBKrUcB0TQ+Ulgkfbi/H/YT5EptrGzsEK7tR1B7ln9BBwckYfMiuSqklSznIuoIIOM42MQO+QnduCoFCI0bpkzjCjddHPN/F+2Yu+sd9bKNpVwHhbS3LluK/0zgfwD0xYI5dXuzlQAAAABJRU5ErkJggg==');
  }

  div.callout-warning.callout-style-default .callout-title {
    background-color: #fcefdc
  }

  div.callout-tip {
    border-left-color: #02b875 !important;
  }

  div.callout-tip .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAADr0lEQVRYCe1XTWgTQRj9ZjZV8a9SPIkKgj8I1bMHsUWrqYLVg4Ue6v9BwZOxSYsIerFao7UiUryIqJcqgtpimhbBXoSCVxUFe9CTiogUrUp2Pt+3aUI2u5vdNh4dmMzOzHvvezuz8xNFM0mjnbXaNu1MvFWRXkXEyE6aYOYJpdW4IXuA4r0fo8qqSMDBU0v1HJUgVieAXxzCsdE/YJTdFcVIZQNMyhruOMJKXYFoLfIfIvVIMWdsrd+Rpd86ZmyzzjJmLStqRn0v8lzkb4rVIXvnpScOJuAn2ACC65FkPzEdEy4TPWRLJ2h7z4cArXzzaOdKlbOvKKX25Wl00jSnrwVxAg3o4dRxhO13RBSdNvH0xSARv3adTXbBdTf64IWO2vH0LT+cv4GR1DJt+DUItaQogeBX/chhbTBxEiZ6gftlDNXTrvT7co4ub5A6gp9HIcHvzTa46OS5fBeP87Qm0fQkr4FsYgVQ7Qg+ZayaDg9jhg1GkWj8RG6lkeSacrrHgDaxdoBiZPg+NXV/KifMuB6//JmYH4CntVEHy/keA6x4h4CU5oFy8GzrBS18cLJMXcljAKB6INjWsRcuZBWVaS3GDrqB7rdapVIeA+isQ57Eev9eCqzqOa81CY05VLd6SamW2wA2H3SiTbnbSxmzfp7WtKZkqy4mdyAlGx7ennghYf8voqp9cLSgKdqNfa6RdRsAAkPwRuJZNbpByn+RrJi1RXTwdi8RQF6ymDwGMAtZ6TVE+4uoKh+MYkcLsT0Hk8eAienbiGdjJHZTpmNjlbFJNKDVAp2fJlYju6IreQxQ08UJDNYdoLSl6AadO+fFuCQqVMB1NJwPm69T04Wv5WhfcWyfXQB+wXRs1pt+nCknRa0LVzSA/2B+a9+zQJadb7IyyV24YAxKp2Jqs3emZTuNnKxsah+uabKbMk7CbTgJx/zIgQYErIeTKRQ9yD9wxVof5YolPHqaWo7TD6tJlh7jQnK5z2n3+fGdggIOx2kaa2YI9QWarc5Ce1ipNWMKeSG4DysFF52KBmTNMmn5HqCFkwy34rDg05gDwgH3bBi+sgFhN/e8QvRn8kbamCOhgrZ9GJhFDgfcMHzFb6BAtjKpFhzTjwv1KCVuxHvCbsSiEz4CANnj84cwHdFXAbAOJ4LTSAawGWFn5tDhLMYz6nWeU2wJfIhmIJBefcd/A5FWQWGgrWzyORZ3Q6HuV+Jf0Bj+BTX69fm1zWgK7By1YTXchFDORywnfQ7GpzOo6S+qECrsx2ifVQAAAABJRU5ErkJggg==');
  }

  div.callout-tip.callout-style-default .callout-title {
    background-color: #ccf1e3
  }

  div.callout-caution {
    border-left-color: #fd7e14 !important;
  }

  div.callout-caution .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAACV0lEQVRYCdVWzWoUQRCuqp2ICBLJXgITZL1EfQDBW/bkzUMUD7klD+ATSHBEfAIfQO+iXsWDxJsHL96EHAwhgzlkg8nBg25XWb0zIb0zs9muYYWkoKeru+vn664fBqElyZNuyh167NXJ8Ut8McjbmEraKHkd7uAnAFku+VWdb3reSmRV8PKSLfZ0Gjn3a6Xlcq9YGb6tADjn+lUfTXtVmaZ1KwBIvFI11rRXlWlatwIAAv2asaa9mlB9wwygiDX26qaw1yYPzFXg2N1GgG0FMF8Oj+VIx7E/03lHx8UhvYyNZLN7BwSPgekXXLribw7w5/c8EF+DBK5idvDVYtEEwMeYefjjLAdEyQ3M9nfOkgnPTEkYU+sxMq0BxNR6jExrAI31H1rzvLEfRIdgcv1XEdj6QTQAS2wtstEALLG1yEZ3QhH6oDX7ExBSFEkFINXH98NTrme5IOaaA7kIfiu2L8A3qhH9zRbukdCqdsA98TdElyeMe5BI8Rs2xHRIsoTSSVFfCFCWGPn9XHb4cdobRIWABNf0add9jakDjQJpJ1bTXOJXnnRXHRf+dNL1ZV1MBRCXhMbaHqGI1JkKIL7+i8uffuP6wVQAzO7+qVEbF6NbS0LJureYcWXUUhH66nLR5rYmva+2tjRFtojkM2aD76HEGAD3tPtKM309FJg5j/K682ywcWJ3PASCcycH/22u+Bh7Aa0ehM2Fu4z0SAE81HF9RkB21c5bEn4Dzw+/qNOyXr3DCTQDMBOdhi4nAgiFDGCinIa2owCEChUwD8qzd03PG+qdW/4fDzjUMcE1ZpIAAAAASUVORK5CYII=');
  }

  div.callout-caution.callout-style-default .callout-title {
    background-color: #ffe5d0
  }

  </style>
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
  

    <link rel="icon" href="../Intro2SL_logo.jpg" type="image/jpg"> 

    <link rel="shortcut icon" href="../Intro2SL_logo.jpg" type="image/jpg">

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700" rel="stylesheet" type="text/css">

  </head>

<body class="quarto-light">
  <div class="reveal">
    <div class="slides">


<section id="section" class="slide level2 logo-slide">
<h2></h2>
</section>
<section id="introduction-to-statistical-learning" class="slide level2 title-slide center">
<h2>Introduction to Statistical Learning</h2>
<h3 id="support-vector-machines---class-11">Support Vector Machines - Class 11</h3>
<h3 id="giora-simchoni">Giora Simchoni</h3>
<h4 id="gsimchonigmail.com-and-add-intro2sl-in-subject"><code>gsimchoni@gmail.com</code> and add <code>#intro2sl</code> in subject</h4>
<h3 id="stat.-and-or-department-tau">Stat. and OR Department, TAU</h3>
</section>
<section id="maximum-margin-classifier" class="slide level2 title-slide center">
<h2>Maximum margin classifier</h2>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>ביחידה הזאת נלמד על אלגוריתם נוסף שנוסח במקור עבור בעיות של קלאסיפיקציה בינארית: הספורט וקטור משינז, או SVM בקיצור.</p>
<p>כמו אדאבוסט גם SVM הגיע מקהילת מדעי המחשב לבעיה ספציפית, והורחב לאחר מכן לבעיות כלליות יותר כמו רגרסיה, וכך נלמד אותו. אולם בניגוד לאדאבוסט בSVM אנחנו מגיעים בסופו של דבר לבעית אופטימיזציה שקצת קשה להסביר בדיוק כיצד פותרים אותה בלי כלים מאופטימיזציה קמורה או חקר ביצועים, לכן לא ניכנס לדרך הפתרון המדויקת. נטען עם זאת שהגענו לבעיה פשוטה יחסית באופטימיזציה שניתנת לפתרון באמצעות תוכנה סטנדרטית.</p>
<p>כמו תמיד, אנחנו מתחילים עם הנחה, ולאט לאט מפירים אותה עד שנגיע לפרוצדורה הסופית.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="a-big-assumption">A big assumption</h3>
<ul>
<li>Suppose <span class="math inline">\(y \in \{-1, 1\}\)</span></li>
<li>Suppose the classes can be separated by a hyperplane, e.g.&nbsp;for data <span class="math inline">\(T = \{(x_1, y_1), \dots, (x_n, y_n)\}\)</span>:</li>
</ul>
<div id="4fc05174" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c11_svm_files/figure-revealjs/cell-2-output-1.png" width="836" height="411"></p>
</figure>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>וההנחה שאנחנו מתחילים היא הנחה גדולה. אנחנו מתחילים כאמור עם Y בינארי שיכול להיות 1 או מינוס 1, ועם מדגם למידה בגודל n.</p>
<p>וההנחה היא שהנתונים שלנו במרחב הX הם לינארלי ספרבל, כלומר ניתן למצוא קו או מישור או מישור-על שמפריד בין התצפיות שהן 1 לבין התצפיות שהן מינוס 1. זאת הנחה כמובן לא סבירה אלא אם המימד של X ממש גבוה. אנחנו עושים אותה במודע ולאחר מכן נאפשר בכל זאת חפיפה בין הקלאסים ואולי אפילו גבול לא לינארי.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="separating-hyperplanes-i">Separating hyperplanes (I)</h3>
<ul>
<li><span class="math inline">\(\beta_0, \beta_1, \dots, \beta_p\)</span> define a <span class="math inline">\(p\)</span>-dimensional plane for all points <span class="math inline">\(x \in \mathbb{R}^p\)</span> satisfying: <span class="math display">\[\beta_0 + \beta_1x_1 + \dots + \beta_px_p = \beta_0 + x^T\beta = 0\]</span></li>
<li>We say <span class="math inline">\(\beta^* = (\beta_1, \dots, \beta_p) / \|\beta\|\)</span> is normal to the hyperplane</li>
</ul>
<div id="47bb4c16" class="cell" data-execution_count="2">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c11_svm_files/figure-revealjs/cell-3-output-1.png" width="288" height="282"></p>
</figure>
</div>
</div>
</div>
<div class="fragment">
<div class="callout callout-note callout-style-simple">
<div class="callout-body">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-content">
<p>What would be a natural decision rule for separating <span class="math inline">\(y \in \{-1, 1\}\)</span>?</p>
</div>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>אם אנחנו מדברים על מישור-על או הייפרפליין שמפריד, בואו ניזכר מה ההגדרה של מישור.</p>
<p>ההגדרה של מישור היא באמצעות הנקודות שמקיימות את המשוואה הליניארית שיש לנו כאן: חותך בטא-אפס ועוד מקדמים כפול משתנים, כל זה שווה לאפס. ניתן לכתוב זאת גם באמצעות המכפלה הפנימית של וקטור המקדמים ללא החותך בטא בוקטור הקואורדינטות X. כלומר מישור הוא מעין לוח של כל הנקודות שמקיימות את המשוואה. כאן למשל מצויר מישור בדו-מימד שהוא בעצם קו, של כל הנקודות שמקיימות -4 + 2x1 + 3x2 = 0.</p>
<p>ניזכר גם שוקטור שמאונך למישור, שיוצר איתו זווית של 90 מעלות והנורמה שלו 1, נקרא נורמל למישור. ואפשר לראות שמעצם ההגדרה של וקטור המקדמים בטא, בטא הוא וקטור נורמל למישור, הוא אורתוגונלי אליו, יוצר איתו זוית של 90 מעלות, או יותר נכון בטא-כוכב שעבר נרמול. אני אומר מעצם ההגדרה כי בטא כפול כל נקודה 1 לחותך, איקס1 איקס2, ייתן אפס, זאת ההגדרה של אורתגונליות. זה יהיה חשוב לנו תיכף. כלומר אפשר להגדיר מישור באמצעות וקטור בטא, ועוד חותך. מישור בטא זה מישור שאנכי לוקטור בטא, כשהחותך בטא אפס אומר לנו כמה להזיז אותו בכיוון בטא.</p>
<p>מכל מקום, אם אפשר למצוא מישור כזה שמפריד בין תצפיות 1 ומינוס 1, מה יהיה כלל החלטה טבעי לחיזוי תצפית חדשה? אם התצפית מעל למישור, כלומר בטא-אפס ועוד X בטא גדול מאפס, אז נחזה 1. ואם התצפית מתחת למישור, כלומר המכפלה קטנה מאפס, נחזה מינוס 1. לשם אנחנו חותרים, זה אכן יהיה כלל ההחלטה שלנו עוד רגע.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="separating-hyperplanes-ii">Separating hyperplanes (II)</h3>
<div>
<ul>
<li class="fragment"><p>In other words, a hyperplane is “separating” iff: <span class="math display">\[y_i \cdot (\beta_0 + x_i^T\beta) &gt; 0 \quad \forall i\]</span></p></li>
<li class="fragment"><p>And a natural decision rule for separating hyperplanes: <span class="math display">\[\hat{f}(x_0) = \text{sign}\left[\hat{\beta}_0 + x_0^T\hat{\beta}\right]\]</span></p></li>
</ul>
</div>
<div class="fragment">
<div class="columns">
<div class="column">
<div class="callout callout-note callout-style-simple">
<div class="callout-body">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-content">
<p>But <em>if</em> there exists a separating hyperplane, how many are there?</p>
</div>
</div>
</div>
</div><div class="column">
<div id="aac9deba" class="cell" data-execution_count="3">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c11_svm_files/figure-revealjs/cell-4-output-1.png" width="327" height="319"></p>
</figure>
</div>
</div>
</div>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>במילים אחרות, כרגע גם מצאנו הגדרה של מהו מישור מפריד, separating. מישור מפריד הוא מישור שעבור מדגם הלמידה שלנו, בכל נקודה (להדגים), אם היא 1 אז היא מעל המישור, ואם היא מינוס 1 אז היא מתחת למישור. ואת זה אנחנו יכולים לרשום בצורה קומפקטית ככה: המכפלה של Y בביטוי המישור חייבת להיות גדולה מאפס לכל התצפיות. כי אם Y הוא 1 הביטוי חיובי אנחנו מעל למישור, פלוס כפול פלוס. ואם Y הוא מינוס 1 הביטוי שלילי אנחנו מתחת למישור, מינוס כפול מינוס.</p>
<p>וכאמור אם נמצא מישור כזה, או אומדים לוקטור בטא ולחותך, זה בסוף יהיה כלל ההחלטה שלנו לכל תצפית חדשה X0: הסיין של הבדיקה הזאת האם הנקודה מעל או מתחת למישור.</p>
<p>אז לפני שנמצא את המישור, צריך להכיר בבעיה של מה שהגדרנו: אם יש מישור כזה, הוא יחיד? לא, (להדגים) יש הרבה מישורים כאלה, למעשה יש אינסוף. ואז נשאל – איזה מישור הכי טוב למטרה שלנו.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="maximum-margin-classifier-1">Maximum margin classifier</h3>
<ul>
<li>Intuitively, we would like the hyperplane that is “fartherst” from points on both sides</li>
</ul>
<div class="fragment">
<ul>
<li>That is, the hyperplane that maximizes the <span style="color:red;">margin</span>:
<ul>
<li>the minimum distance of training points to the hyperplane</li>
</ul></li>
</ul>
<div id="2a009c51" class="cell" data-execution_count="4">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c11_svm_files/figure-revealjs/cell-5-output-1.png" width="758" height="374"></p>
</figure>
</div>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>בצורה אינטואיטיבית, נגיד, שהיינו רוצים את המישור, שהוא הכי רחוק מהתצפיות של מדגם הלמידה. כלומר לכל כיוון נרצה את המישור שהוא כמה שיותר באמצע, סביר להניח שזה כלל ההחלטה שיעבור הכללה הכי טובה לתצפיות שהמודל לא ראה.</p>
<p>דרך אחרת להגיד אותו דבר, היא המישור שעושה מקסימום לרווח בין שני הקלאסים, למה שאנחנו קוראים מרג’ין. ולכן לקלסיפייר הנאיבי שנפתח קוראים מקסימום מרג’ין קלסיפייר.</p>
<p>כאן למשל יש שני מישורים שמביאים לשני מרג’ינים, שניהם מפרידים לנו בין הקלאסים. המרג’ין השמאלי אינטואיטיבית נראה טוב יותר כי הוא פשוט עבה יותר, למעשה הוא המרג’ין המקסימלי שאפשר להגיע אליו עם מדגם הלמידה הזה.</p>
<p>נשים לב עוד שלכל נקודה יש מרחק אנכי אל המישור. המרג’ין מוגדר על ידי הנקודות עם המרחק המינימלי למישור. ואנחנו רוצים לעשות מקסימום למרחק הזה, כלומר זאת בעית מקסימום למינימום מרחק.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="maximum-margin-criterion">Maximum margin criterion</h3>
<div>
<ul>
<li class="fragment"><p>So far we have:<br>
<span class="math inline">\(\max_{\beta, \beta_0}\text{"minimum distance"} \quad s.t. \space y_i (\beta_0 + x_i^T\beta) &gt; 0 \quad \forall i\)</span></p></li>
<li class="fragment"><p>The distance between any point <span class="math inline">\(x\)</span> to the hyperplane is: <span class="math inline">\(\frac{|\beta_0 + x^T\beta|}{\|\beta\|_2}\)</span></p>
<ul>
<li class="fragment">because this distance is the length of a vector proportional to the normal <span class="math inline">\(\beta\)</span>:</li>
</ul></li>
</ul>
</div>
<div class="fragment">
<div id="27223af4" class="cell" data-execution_count="5">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c11_svm_files/figure-revealjs/cell-6-output-1.png" width="362" height="361"></p>
</figure>
</div>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>אז איך אנחנו מנסחים את הקריטריון הזה בצורה שגם נוכל להשיג אותו?</p>
<p>הבנו שאנחנו רוצים את המקסימום של “מינימום מרחק”, הבנו שהפרמטרים שלנו הם מה שמגדיר את המישור עצמו, וקטור המקדמים של משוואת המישור, או הנורמל למישור ועוד חותך. והבנו שיש לנו אילוץ שנובע מההנחה שלנו, זה חייב להיות מישור מפריד, מה שמתבטא באילוץ שרשום כאן לכל תצפית i. כל שנשאר לנו זה לפרמל מה זה מינימום מרחק.</p>
<p>אז אם אתם יודעים מלימודי המתמטיקה שלכם, יש לנו נוסחה של מרחק של כל נקודה למישור שמוגדר על-ידי וקטור המקדמים בטא: זה בעצם המכפלה הפנימית בין הנקודה לוקטור המקדמים, ועוד חותך, בערך מוחלט, חלקי הנורמה של וקטור המקדמים.</p>
<p>אפשר להוכיח את זה אבל יש כאן משהו מאוד אינטואיטיבי: הנה נקודה X ואני רוצה לבדוק מה המרחק האנכי שלה למישור נתון. אפשר לראות שהמרחק הזה הוא אורך של וקטור שהוא מקביל לוקטור בטא הנורמל. ולכן האורך פרופורציונלי לאורך וקטור בטא הנורמל. כדי להשיג את המקטע הזה אנחנו מטילים את הנקודה X על בטא, והטלה פירושה המכפלה הפנימית בין שני הוקטורים, שמופיעה בביטוי שלנו.</p>
<p>בפרט, אם נדרוש שוקטור בטא יהיה בעל אורך 1, וקטור יחידה, אז המרחק של כל נקודה למישור הוא המכפלה של הקואורדינטות שלה בוקטור המקדמים של המישור ועוד חותך (להדגים). אם זה שווה לאפס הנקודה מקיימת את משוואת המישור, היא על המישור, אם זה גדול מאפס היא מעליו, ואם זה קטן מאפס היא מתחתיו ואנחנו לוקחים את הערך המוחלט.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="maximum-margin-criterion-1">Maximum margin criterion</h3>
<div>
<ul>
<li class="fragment"><p>So for any <span class="math inline">\(M &gt; 0\)</span> a compact way of writing the criterion is: <span class="math display">\[\max_{\beta, \beta_0}M \quad s.t. \space \|\beta\| = 1 \text{ and } \quad y_i (\beta_0 + x_i^T\beta) \ge M \quad \forall i\]</span></p></li>
<li class="fragment"><p>All the points are at least a distance <span class="math inline">\(M\)</span> from the decision boundary defined by <span class="math inline">\(\beta, \beta_0\)</span>, and we seek <span class="math inline">\(\beta, \beta_0\)</span> that get the largest such <span class="math inline">\(M\)</span></p></li>
<li class="fragment"><p>Equivalently if we insist on setting <span class="math inline">\(\|\beta\| = 1/M\)</span> we can write: <span class="math display">\[\min_{\beta, \beta_0}\|\beta\| \quad s.t. \space y_i (\beta_0 + x_i^T\beta) \ge 1 \quad \forall i\]</span></p>
<ul>
<li class="fragment">because <span class="math inline">\(M = 1/\|\beta\|\)</span> and maximizing <span class="math inline">\(M\)</span> is minimizing <span class="math inline">\(\|\beta\|\)</span></li>
</ul></li>
<li class="fragment"><p>This is a convex optimization problem (quadratic criterion if we write <span class="math inline">\(\|\beta\|^2\)</span>, linear inequality constraints), many efficient solvers exist</p></li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>אז נסמן את המרחק הזה, את המרג’ין בM.</p>
<p>דרך לסכם את כל מה שדרשנו עד עכשיו היא לעשות מקסימום על M, ככה שוקטור המקדמים שלנו יהיה וקטור יחידה, יהיה באמת נורמל למישור. ועבור כל תצפית i במדגם הלמידה, נחשב את המרחק שלה מהמישור עם הביטוי שמצאנו, ונדרוש שהמרחק הזה יהיה לפחות M. כלומר M הוא המרחק המינימלי. אבל מה זה מרחק, זה הביטוי שרשום בסוגריים בערך מוחלט. אם הנקודה מעל המישור הY שלה הוא 1, אז מכפילים את המרחק פי 1, אין בעיה והביטוי נשאר כפי שהוא, ואם היא מתחת למישור הY שלה הוא מינוס 1 ולכן ההכפלה בו מביאה אותנו גם כן למרחק חיובי.</p>
<p>או במילים אחרות: כל הנקודות חייבות להיות במרחק לפחות M מהמישור שמוגדר על-ידי הנורמל בטא והחותך בטא-אפס, ואנחנו מחפשים בטא ובטא-אפס שיביאו למקסימום את המרחק הזה, את המרג’ין.</p>
<p>נשים לב שאפשר היה עקרונית לקבע את הנורמה של בטא על כל ערך, ואם נחליט שהנורמה של בטא לא חייבת להיות 1 אלא 1 חלקי M, אפשר להיפטר גם מהפרמטר M בבעית האופטימיזציה שלנו. כעת כדי להגדיל את M כמה שיותר צריך להקטין את הנורמה של וקטור בטא כמה שיותר. וככה אנחנו גם נפטרים מM וגם הופכים את הבעיה שלנו לבעית מינימום.</p>
<p>זאת הנקודה שבה הבטחתי שאנחנו עוצרים ולא נכנסים לדיון על אופטימיזציה, רק מצביעים על כך שאפשר לעשות מינימום לנורמה הריבועית (להדגים) ויש לנו בעית אופטימיזציה קמורה יחסית פשוטה: הפונקציה שלנו קמורה ואנחנו עושים מינימום, כלומר מובטח לנו שנמצא מינימום תחת ההנחה שלנו של ספרביליות, והאילוצים הם אי-שוויונות ליניאריים בבטא, אפשר לפתור את זה בכל אלגוריתם או תוכנה לאופטימיזציה סטנדרטית.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="support-vectors">Support vectors</h3>
<div class="columns">
<div class="column">
<p>Back to the maximum margin classifier:</p>
<div id="154dbb79" class="cell" data-execution_count="6">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c11_svm_files/figure-revealjs/cell-7-output-1.png" width="374" height="374"></p>
</figure>
</div>
</div>
</div>
</div><div class="column">
<div>
<ul>
<li class="fragment">The final classifier depends only on support vectors but was reached given all the training data</li>
<li class="fragment">Advantages/disadvantages to a classifier that only depends on few observations</li>
<li class="fragment">What would logistic regression do?</li>
<li class="fragment">What if there is no separable hyperplane?</li>
<li class="fragment">And as usual: this is very specific to binary classification, can we generalize?</li>
</ul>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>אם נסתכל שוב על המוטיבציה שלנו – אנחנו רוצים למצוא את המישור שממקסם את המרג’ין בין שני הקלאסים - רמזנו לזה כבר קודם אבל כעת אנחנו אומרים במפורש, ניתן לראות שהמרג’ין הזה ברגע שנמצא, הוא מושפע רק מקבוצה קטנה של תצפיות. אם הן יזוזו, גם המישור והמרג’ין יושפעו. אבל אם כל אחת מהתצפיות האחרות יזוזו? בתנאי שיישארו בצד הנכון של המישור ולא ייכנסו פנימה? לא תהיה לזה השפעה על המישור והמרג’ין. לכן הנקודות שבעצם מגדירות את המרג’ין הסופי נקראות נקודות או וקטורים של תמיכה support vectors. ומכאן השם של הבעיה הסופית שנלמד ששומרת על העקרון הזה, סאפורט וקטור מאשינז. למעשה, ניתן להגדיר את כל הבעיה בדרך של מציאת הנקודות שיהיו הסאפורט וקטורז למרג’ין המקסימלי.</p>
<p>כמה הערות לסיום:</p>
<p>קודם כל, חשוב להדגיש שאמנם החיזוי הסופי מושפע רק מהסאפורט וקטורז, ועוד נראה ביטוי מתמטי לזה. אבל זה לא שזרקנו את שאר המדגם, השתמשנו בו כדי להגיע אליהם, כמו שאמרתי אפשר לנסח את כל הבעיה כחיפוש על הנקודות, לא מציאת נורמל למישור.</p>
<p>דבר שני, עם כל מה שלמדתם אתם כבר יכולים לתאר לכם מה יכולים להיות היתרונות והחסרונות בקלסיפייר כזה, שמבוסס רק על סט קטן של תצפיות: למשל הוא מושפע פחות מתצפיות חריגות. קראנו לזה מודל חסין או רובסטי מפני תצפיות חריגות. מצד שני אנחנו תיכף נראה שאמנם המודל לא מושפע מתצפיות שרחוקות מהמרג’ין, אבל הוא מאוד מושפע מתצפיות שקרובות למרג’ין. נזיז תצפית אחת מהסאפורט וקטורז בכיוון קצת לא צפוי והמודל יכול להשתנות בצורה גסה.</p>
<p>שאלה חשובה שיש עליה הרבה מחקר היא מה בעצם ההבדל מרגרסיה לוגיסטית? הרי גם רגרסיה לוגיסטית אם הדאטא הוא ספרבילי אמורה למצוא מישור מפריד דומה מאוד – וזה אכן מה שקורה, אם תריצו רגרסיה לוגיסטית על המדגם שכאן תקבלו משוואה שמאוד מזכירה את משוואת המישור שהמקסימום מרג’ין קלסיפייר מוצא. ולרגרסיה לוגיסטית יש גם פירוש הסתברותי, ופונקצית הפסד הסתברותית.</p>
<p>שתי השאלות שנדון בהן כעת הן המתבקשות ביותר: אחת, מה עם הדאטא הוא לא ספרבילי? הרי אין מישור למצוא. והשנייה היא האם יש דרך להכליל את הרעיון היצירתי הזה מקלסיפיקציה בינארית לכמה קלאסים ולרגרסיה עם Y רציף.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="support-vector-classifier" class="slide level2 title-slide center">
<h2>Support vector classifier</h2>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>רילקסציה ראשונה לקריטריון שלנו – אנחנו רוצים שזה יעבוד גם במקרה שיש קצת חפיפה. כלומר לא נניח יותר שהדאטא הוא ספרבילי. זה יביא אותנו סוף סוף למודל שנקרא סאפורט וקטור קלסיפייר.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="not-just-the-non-separable-case">Not just the non-separable case</h3>
<div id="49f17ad1" class="cell" data-execution_count="7">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c11_svm_files/figure-revealjs/cell-8-output-1.png" width="950" height="278"></p>
</figure>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>כבר הזכרנו ונדגים את זה, שהבעיה היא לא רק שיש חפיפה ואין אפשרות למצוא מישור מפריד, כמו בדאטא בתרשים בצד ימין. הבעיה היא גם אם כן אפשר למצוא מישור מפריד אבל המרג’ין שנוצר הוא כל כך צר שזה נראה מאולץ. או במילים אחרות נוצר לנו מצב של אוברפיטינג, ואולי נרצה להתחשב קצת פחות בכל נקודה ונקודה. אני יוצר מצב כזה בדאטא בתרשים האמצעי, על-ידי הוספה של נקודה כחולה אחת ויחידה בצורה כזו. המודל משתנה בצורה דרסטית! איך קראנו לזה? מודל לא יציב, עם שונות מאוד גבוהה.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="support-vectors-classifier">Support vectors classifier</h3>
<ul>
<li>Let us relax our constraints:
<ul>
<li>Allow observations to be inside the margin</li>
<li>Or even on the wrong side of the hyperplane!</li>
<li>With a “budget” <span class="math inline">\(C\)</span> for these violations (or penalty)</li>
</ul></li>
</ul>
<div>
<ul>
<li class="fragment"><p>We do this with the help of “slack variables”: <span class="math inline">\(\epsilon = (\epsilon_1, \dots, \epsilon_n)\)</span></p></li>
<li class="fragment"><p>The new optimization problem: <span class="math display">\[\max_{\beta, \beta_0, \epsilon}M \quad s.t. \space \|\beta\| = 1, \quad y_i (\beta_0 + x_i^T\beta) \ge M(1-\epsilon_i), \quad \epsilon_i \ge 0, \quad \sum_{i = 1}^n \epsilon_i \le C\]</span></p></li>
<li class="fragment"><p>The final prediction is still: <span class="math display">\[\hat{f}(x_0) = \text{sign}\left[\hat{\beta}_0 + x_0^T\hat{\beta}\right]\]</span></p></li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>אז אנחנו נרשה לחלק מהתצפיות להיות גם בתוך המרג’ין.</p>
<p>או אפילו: לתצפיות מסוימות להיות בצד הלא נכון של המישור!</p>
<p>ואנחנו נעשה את זה באמצעות פרמטר C שיהיה תקציב לחריגות כאלה, מאוד מזכיר את מה שעשינו ברגרסיה עם רגולריזציה כמו רידג’ ולאסו.</p>
<p>אנחנו עושים את זה עם אוסף של n פמרטרים לn תצפיות, שאנחנו קוראים להם משתני סלאק, מלשון to cut some slack. נסמן אותם בוקטור אפסילון.</p>
<p>וכעת אנחנו עושים מקסימום על M המרחק המינימלי של התצפיות אל המישור, ככה שוקטור המקדמים בטא הוא בנורמה אחת כלומר הוא נורמל, והמרחק גדול או שווה לא לM אלא לM כפול קצת פחות מ1, כי הוא מוכפל פי 1 מינוס אפסילון i לכל תצפית. אנחנו כמובן גם חייבים לוודא שהאפסילונים הם חיוביים, וכאמור נחסום את הסכום שלהם באמצעות איזשהו פרמטר תקציב C שעכשיו אנחנו חייבים לספק, ותיכף נרחיב על זה. נשים לב גם שהמקסימום על המרג’ין הוא עכשיו גם על עוד וקטור של משתני סלאק אפסילון, כלומר נצטרך להגיע להחלטה כזאת לכל תצפית ותצפית.</p>
<p>ולמרות הכל, בשורה התחתונה המודל שנוצר בסאפורט וקטור קלאסיפייר, הוא בעל צורה זהה למודל של מקסימום מרג’ין קלסיפייר: אנחנו בסופו של דבר חוזים 1 אם תצפית מעל המישור ומינוס 1 אם היא מתחת.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="svc-slack-variables">SVC: slack variables</h3>
<p><span class="math inline">\(\max_{\beta, \beta_0, \epsilon}M \quad s.t. \space \|\beta\| = 1, \quad y_i (\beta_0 + x_i^T\beta) \ge M(1-\epsilon_i), \quad \epsilon_i \ge 0, \quad \sum_{i = 1}^n \epsilon_i \le C\)</span></p>
<div>
<ul>
<li class="fragment"><span class="math inline">\(\epsilon_i\)</span> is the amount by which observation <span class="math inline">\(x_i\)</span> “violates” the margin:
<ul>
<li class="fragment">If <span class="math inline">\(\epsilon_i = 0\)</span> then <span class="math inline">\(x_i\)</span> is on the correct side of the margin</li>
<li class="fragment">If <span class="math inline">\(\epsilon_i &gt; 0\)</span> then <span class="math inline">\(x_i\)</span> is on the wrong side of the margin</li>
<li class="fragment">If <span class="math inline">\(\epsilon_i &gt; 1\)</span> then <span class="math inline">\(x_i\)</span> is on the wrong side of the hyperplane!</li>
</ul></li>
</ul>
</div>
<div id="8a311ccf" class="cell" data-execution_count="8">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c11_svm_files/figure-revealjs/cell-9-output-1.png" width="950" height="278"></p>
</figure>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>אז בואו נדבר קצת על הסלאק וריאבלז האלה:</p>
<p>בתרשים השמאלי, אין בהם צורך. כל התצפיות במרחק M לפחות, ולכן כל האפסילונים שווים אפס.</p>
<p>בתרשים האמצעי אנחנו מאפשרים שתי הפרות: יש שתי נקודות שנמצאות בתוך המרג’ין, אחת כחולה ואחת אדומה, כלומר יש שני אפסילונים חיוביים, והשאר אפס. יש לנו כאן דוגמא לדאטא שהוא ספרבילי אבל אם לא נאפשר קצת סלאק, נקבל את המרג’ין הצר והמאולץ שקיבלנו קודם, וכעת מתאפשר מרג’ין הרבה יותר יציב.</p>
<p>בתרשים הימני שהוא כבר המקרה הלא-ספרבילי, יש לנו כמה משתני סלאק שהם גדולים מאפס. כאן יש לנו אפילו נקודות שהן בצד הלא נכון של המישור (להדגים). בשביל הנקודות האלה האפסילונים שנמצאו הם גדולים מ1, הם יוצאים מעבר לחצי המרג’ין M.</p>
<p>אז נסכם, האפסילונים הם בסופו של דבר הכמות שבה התצפיות “מפירות” את המרג’ין:</p>
<p>אם אפסילון שווה אפס, התצפית בצד הנכון של המרג’ין, אין צורך בסלאק.</p>
<p>אם אפסילון גדול מאפס, היא בצד הלא נכון של המרג’ין. היא או נכנסת בתוכו או אפילו מחוצה לו, בצד הלא נכון של המישור.</p>
<p>אם אפסילון גדול מ1 אז בודאות התצפית בצד הלא נכון של המישור, אולי בתוך המרג’ין, אולי אפילו מחוצה לו.</p>
<p>והדרך שלנו לשלוט בכמה סלאק אנחנו מאפשרים היא דרך פרמטר C, אז נדבר עליו גם כן.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="svc-the-c-parameter">SVC: the <span class="math inline">\(C\)</span> parameter</h3>
<p><span class="math inline">\(\max_{\beta, \beta_0, \epsilon}M \quad s.t. \space \|\beta\| = 1, \quad y_i (\beta_0 + x_i^T\beta) \ge M(1-\epsilon_i), \quad \epsilon_i \ge 0, \quad \sum_{i = 1}^n \epsilon_i \le C\)</span></p>
<div>
<ul>
<li class="fragment"><span class="math inline">\(C\)</span> is the amount by which the margin may be “violated”:
<ul>
<li class="fragment">If <span class="math inline">\(C = 0\)</span> then <span class="math inline">\(\epsilon = \mathbf{0}\)</span>, back to maximum margin classifier</li>
<li class="fragment">If <span class="math inline">\(C &gt; 0\)</span> no more than <span class="math inline">\(C\)</span> observations can be on the wrong side of the hyperplane</li>
</ul></li>
</ul>
</div>
<div id="136c4ca1" class="cell" data-execution_count="9">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c11_svm_files/figure-revealjs/cell-10-output-1.png" width="950" height="278"></p>
</figure>
</div>
</div>
</div>
<div class="fragment">
<div class="callout callout-note callout-style-simple">
<div class="callout-body">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-content">
<p>How to choose <span class="math inline">\(C\)</span>? What is the relation between <span class="math inline">\(C\)</span> and the bias-variance tradeoff?</p>
</div>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>אם C הוא אפס, יש לנו אפס סבלנות להפרה של המרג’ין, כל האפסילונים יהיו אפס, בעצם אנחנו חוזרים למקסימום מרג’ין קלסיפייר.</p>
<p>אם C גדול מאפס אנחנו כן מאפשרים סלאק, ויותר מזה C הוא חסם על מספר התצפיות שאנחנו מוכנים שיעברו את המישור, כי כל תצפית כזאת תקבל אפסילון יותר מ1.</p>
<p>כאן יש לנו את אותו סט של נתונים שחוזר על עצמו עם C שונים. אפשר לראות כשC התקציב נורא קטן אין כמעט הקצאה להפרה של המרג’ין, מתקבל מרג’ין צר מאוד שמתאים את עצמו מאוד לדאטא, עם מעט סאפורט וקטורז. מנגד, כשC גדול מאוד, מקבלים מרג’ין עבה, שפחות נצמד לדאטא, ויש למודל הרבה מאוד סאפורט וקטורז שמשפיעים עליו.</p>
<p>אז איך נבחר איזה C לתת למודל? פשוט: נתייחס לC כאל היפרפרמטר, כאל איזה כפתור שאפשר לסובב וצריך לבדוק כמה לסובב אותו באמצעות שיטות שלמדנו כמו קרוס ולידיישן. וברור שכאן אנחנו רואים קשר מיידי לביאס-וריאנס טריידאוף. מומלץ לעצור רגע את ההקלטה ולחשוב לבד איך C משפיע על הטריידאוף.</p>
<p>עצרתם? אוקי, אז כמו שאפשר לראות כאן ככל שC גדול יותר, המרג’ין גדול ויציב כי הוא מתחשב בהרבה סאפורט וקטורז, במילים אחרות השונות נמוכה. אבל, הביאס יכול לגדול כי המישור שמצאנו כבר לא מתאים את עצמו לקו המאוד ספציפי שמקבלים בין הקלאסים. מצד שני כשC קטן המרג’ין מאוד צר, כל שינוי במעט סאפורט וקטורז שיש לו יכול מאוד לערער אותו, כלומר שונות גבוהה. אבל הביאס קטן כי אנחנו מתקרבים לקו הספציפי שמתאים עצמו הכי לנתונים.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="svc-equivalent-forms">SVC: equivalent forms</h3>
<ul>
<li><p>As with maximum margin classifier, if we insist on setting <span class="math inline">\(\|\beta\| = 1/M\)</span> we can write: <span class="math display">\[\min_{\beta, \beta_0, \epsilon}\|\beta\| \quad s.t. \space y_i (\beta_0 + x_i^T\beta) \ge 1-\epsilon_i, \quad \epsilon_i \ge 0, \quad \sum_{i = 1}^n \epsilon_i \le C \quad \forall i\]</span></p></li>
<li><p>In fact, it is more common to see the equivalent form: <span class="math display">\[\min_{\beta, \beta_0, \epsilon}\frac{1}{2}\|\beta\|^2 + C \sum_{i = 1}^n \epsilon_i \quad s.t. \space y_i (\beta_0 + x_i^T\beta) \ge 1-\epsilon_i, \quad \epsilon_i \ge 0 \quad \forall i\]</span></p></li>
<li><p>In which case, notice the <span class="math inline">\(C\)</span> hyperparameter is now a <em>penalty</em> (this is also more similar to how sklearn sees it)</p></li>
</ul>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>נסיים את הדיון בסאפורט וקטור קלסיפייר בזה שנזכיר שבדרך כלל אנחנו רואים צורה מעט שונה של הקריטריון.</p>
<p>קודם כל גם כאן ניתן להיפטר מM עצמו, חצי העובי של המרג’ין, אם פשוט קובעים שהנורמה של וקטור המקדמים בטא היא 1 חלקי M. העניין הוא שבקריטריון בלי M קצת קשה להבין את התפקיד של הסלאק וריאבלז, האפסילונים.</p>
<p>ולמעשה, הרבה פעמים תפגשו בכלל את הקריטריון של SVC בצורה כזאת: מינימום על הנורמה הריבועית של וקטור המקדמים בטא, כדי להפוך את הבעיה לקמורה, וC לא מופיע כפרמטר תקציב אלא כפרמטר עונש על סכום האפסילונים.</p>
<p>זה חשוב להבין את זה כי ככה גם המימוש בsklearn, ככל שC גדול אנחנו מענישים יותר את הסלאק וריאבלז ונראה מרג’ינים צרים יותר, וככל שהוא קטן אנחנו מענישים פחות את הסכום שלהם, נראה הרבה הפרות של המרג’ינים שיהיו עבים יותר.</p>
<p>עד כאן על סאפורט וקטור קלסיפיירז. ביחידה הבאה נוותר גם על דרישה הזאת שמישור מפריד בין הקלאסים, אלא כל יריעה אחרת, ונגיע לפרוצדורה הסופית שנקראת סאפורט וקטור מאשינז.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="support-vector-machines-svm" class="slide level2 title-slide center">
<h2>Support vector machines (SVM)</h2>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>אז מה הופך סאפורט וקטור קלסיפיירז לסאפורט וקטור מאשינז?</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="the-non-linear-case">The non-linear case</h3>
<p>Recall the Bayes decision boundary example from our Bias-Variance discussion:</p>
<div id="0b6ebf09" class="cell" data-execution_count="10">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c11_svm_files/figure-revealjs/cell-11-output-1.png" width="642" height="434"></p>
</figure>
</div>
</div>
</div>
<div class="fragment">
<p>Unfortunately, “real data” looks more like this.</p>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>למשל מה קורה אם אין מישור מפריד, עם או בלי סלאק, אבל כן יש יריעה מסוימת שמפרידה. במילים אחרות אם ההפרדה היא לא ליניארית.</p>
<p>ראינו דוגמה כזאת ממש כשדיברנו על הטריידאוף בין ביאס ווריאנס בקלסיפיקציה, שם תיארנו לנו שיש איזו פונקצית הסתברות להיות בקלאס 1 לעומת הקלאס מינוס 1, והנחנו שהיא משתנה בצורה חלקה כזאת במרחב של X. מה סאפורט וקטור קלסיפייר יכול לעשות במקרה כזה? מעט מאוד.</p>
<p>ולצערי דאטא אמיתי הרבה פעמים נראה ככה, עם תופעות לא-ליניאריות. אז אנחנו צריכים למצוא דרך להכליל את המתודה שלנו לעולם לא ליניארי.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="adding-polynomial-terms">Adding polynomial terms?</h3>
<div>
<ul>
<li class="fragment"><p>Similar to polynomial regression we could add quadratic terms: <span class="math display">\[\max_{\beta^1, \beta^2, \beta_0, \epsilon}M \quad s.t. \\
\|\beta^1\|^2 + \|\beta^2\|^2 = 1, \quad y_i (\beta_0 + x_i^T\beta^1 + \left(x^2_i\right)^T\beta^2) \ge M(1-\epsilon_i)\]</span> <span class="math display">\[\quad \epsilon_i \ge 0, \quad \sum_{i = 1}^n \epsilon_i \le C\]</span></p></li>
<li class="fragment"><p>What about cubic terms? What about interactions?</p></li>
<li class="fragment"><p>Like in regression we could <em>expand</em> <span class="math inline">\(x_i\)</span> to any feature mapping <span class="math inline">\(h(x_i): \mathbb{R}^p \to \mathbb{R}^q\)</span> and continue as is</p></li>
<li class="fragment"><p>But this becomes really high-dimensional, really fast.</p></li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>כשדיברנו על רגרסיה והמודל הליניארי הצענו אפשרות קלה ממש, וזה להוסיף גורמים פולינימיאליים.</p>
<p>כאן למשל, אני רושם את הבעיה שוב, רק שהפעם יש לי וקטור מקדמים בטא1 ועוד וקטור מקדמים בטא2 ששייך לכל הגורמים של X בריבוע. הנורמה של כל הוקטור צריכה להיות 1, וחוץ מזה אין שינוי. בעצם הגדלתי את המרחב של המישור שלי מp ל2p. אבל התוצאה תהיה כמו שנראה תיכף כלל החלטה לא-ליניארי במישור המקורי של האיקסים.</p>
<p>ומה עם גורמים בשלישית, ומה עם אינטראקציות, מסדר שני, שלישי וכולי?</p>
<p>כמו ברגרסיה אפשר להרחיב את X לאיזשהו מיפוי h(X) ולהמשיך כרגיל.</p>
<p>הבעיה היא למשל חישובית. בדרך כלל אם רוצים להתחשב למשל בכל האינטראקציות q נעשה גדול מאוד מהר מאוד, אולי אפילו יותר מכמות התצפיות. באופן מפתיע יש טריק שאפשר להפעיל שהוא אגב לא ייחודי למודל סאפורט וקטור, והוא מאפשר לנו לקבל את המודל בלי צורך לפרט ולחשב את כל הh(X) הארוך הזה.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="the-kernel-trick-i">The kernel trick (I)</h3>
<div>
<ul>
<li class="fragment">An amazing insight, after a lot of algebra, our solution can be written as: <span class="math display">\[f(x_0) = \text{sign}\left[\beta_0 + x_0^T\beta\right] = \text{sign}\left[\beta_0 + \sum_{i = 1}^n\alpha_i\langle x_i, x_0 \rangle\right]\]</span></li>
<li class="fragment">where:
<ul>
<li class="fragment"><span class="math inline">\(\langle x_i, x_0 \rangle\)</span> is the inner product <span class="math inline">\(x_i^Tx_0 = \sum_{j = 1}^p x_{ij}x_{0j}\)</span></li>
<li class="fragment"><span class="math inline">\(\alpha_i, \dots, \alpha_n\)</span> are <span class="math inline">\(n\)</span> parameters for <span class="math inline">\(n\)</span> observations,
<ul>
<li class="fragment">but <span class="math inline">\(\alpha_i &gt; 0\)</span> only for support vectors, otherwise <span class="math inline">\(\alpha_i = 0\)</span></li>
</ul></li>
</ul></li>
<li class="fragment">So for any <span class="math inline">\(h(x_i)\)</span>, the solution can be written in terms of inner products only: <span class="math display">\[f(x_0) = \text{sign}\left[\beta_0 + h(x_0)^T\beta\right] = \text{sign}\left[\beta_0 + \sum_{i = 1}^n\alpha_i\langle h(x_i), h(x_0) \rangle\right]\]</span></li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>הטריק שלנו נקרא הקרנל טריק. והוא שהופך סאפורט וקטור קלסיפייר לסאפורט וקטור מאשין. באופן כללי יש עולם שלם של שיטות קרנל שלא נלמד, מי שרוצה יכול לקחת קורסים מתקדמים יותר או לקרוא על זה עוד בספרים, זה מאוד שימושי.</p>
<p>חוקרים הבחינו שבאופן מדהים אפשר לנסח את המודל שלנו לא בשפת המקדמים, בטא1 עד בטאp, אלא בשפת התצפיות, עם וקטור פרמטרים בגודל n שנסמן כאלפא.</p>
<p>ניקח תצפית חדשה X0. האלפות שלנו לא מכפילות את התצפית עצמה אלא את המכפלה הפנימית של התצפית עם תצפית Xi. כלומר אפשר לכתוב את המודל כך (להדגים).</p>
<p>וכאמור יש לנו פרמטר אלפא-איי לכל תצפית i, והנה עובדה מרתקת: אפשר להראות שבהכרח אלפא-איי גדול מאפס רק עבור אותן תצפיות שהן סאפורט וקטורז, שמגדירות את המרג’ין. אחרת, הוא אפס. כלומר בלי קשר לטריק הקרנל שתיכף נראה, המודל של סאפורט וקטור כולל צורה דואלית ברמת התצפיות שמראה ממש איך הוא תלוי רק בקבוצה מסוימת שלהן. כשבאה תצפית חדשה, מספיק לחשב את המכפלה הפנימית שלה עם כל אחד מהסאפורט וקטורז בלבד, להכפיל פי איזו משקולת אלפא-איי ולסכום. החיזוי של תצפית חדשה יקבע רק באמצעות היחס שלה לסאפורט וקטורז, התרומה של כל תצפית אחרת היא אפס.</p>
<p>בחזרה לקרנל: אם ככה, זה אומר שעבור כל הרחבה של X ממימד q שהוא אולי גדול הרבה יותר, עדיין אפשר לרשום את הפתרון כקומבינציה של מכפלות פנימיות, פשוט המכפלות הפנימיות הן במרחב החדש הזה של h(X).</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="the-kernel-trick-ii">The kernel trick (II)</h3>
<div>
<ul>
<li class="fragment">Now suppose <span class="math inline">\(x_i = (x_{i1}, x_{i2})\)</span> and <span class="math inline">\(h: \mathbb{R}^2 \to \mathbb{R}^6\)</span> is: <span class="math display">\[h(x_i) = (1, \sqrt{2}x_{i1}, \sqrt{2}x_{i2}, x^2_{i1}, x^2_{i2}, \sqrt{2}x_{i1}x_{i2})\]</span></li>
<li class="fragment">Amazingly, the inner product with any point <span class="math inline">\(x_0\)</span> is quite compact:</li>
</ul>
</div>
<div class="fragment">
<p><span class="math inline">\(\langle h(x_i), h(x_0) \rangle = \begin{pmatrix}1 &amp; \sqrt{2}x_{i1} &amp; \sqrt{2}x_{i2} &amp; x^2_{i1} &amp; x^2_{i2} &amp; \sqrt{2}x_{i1}x_{i2}\end{pmatrix} \begin{pmatrix}1 \\ \sqrt{2}x_{01} \\ \sqrt{2}x_{02} \\ x^2_{01} \\ x^2_{02} \\ \sqrt{2}x_{01}x_{02}\end{pmatrix}=\)</span> <span class="math inline">\(= (1 + x_i^Tx_0)^2\)</span></p>
</div>
<div class="fragment">
<div class="callout callout-note callout-style-simple">
<div class="callout-body">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-content">
<p>Why is that helpful?</p>
</div>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>בואו ניתן דוגמא: נניח שאני נמצא בעולם עם שני משתנים, דו-מימדי, וההרחבה שלי פולינומית ואכן כוללת חותך, את המשתנים עצמם, את המשתנים בריבוע, ואינטראקציה בין שני המשתנים. כלומר בסך הכל עברתי למרחב ממימד 6. נכון שאני מוסיף גורמים של שורש 2 אבל זה לא משנה דבר ותיכף נבין למה אני עושה את זה.</p>
<p>איך נראית המכפלה הפנימית בין ההרחבה h של תצפית חדשה x0 לתצפית קיימת במדגם הלמידה x1? האמת שדי פשוט:</p>
<p>אם תבצעו את המכפלה הפנימית ותסדרו את האיברים, תגלו שקיבלתם ביטוי קטן ופשוט בשפה המקורית של האיקסים: 1 ועוד המכפלה הפנימית של וקטור המשתנים המקורי Xi כפול X0, כל זה בריבוע.</p>
<p>במה זה עוזר לנו? זה עוזר לנו כי המכפלה הפנימית היא כל מה שאנחנו צריכים, וגילינו שאנחנו יכולים לעשות אותה במימד המקורי של X, המימד הנמוך יותר שבו צריך להכפיל שני וקטורים באורך 2, לא באורך 6.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="the-kernel-trick-iii">The kernel trick (III)</h3>
<div>
<ul>
<li class="fragment">Let this be a <span style="color:red;">kernel</span> function: <span class="math display">\[\langle h(x_i), h(x_0) \rangle = (1 + x_i^Tx_0)^2 = K(x_i, x_0)\]</span></li>
<li class="fragment">Back to our solution: <span class="math display">\[f(x_0) = \text{sign}\left[\beta_0 + \sum_{i = 1}^n\alpha_i\langle h(x_i), h(x_0) \rangle\right] = \text{sign}\left[\beta_0 + \sum_{i = 1}^n\alpha_i K(x_i, x_0)\right]\]</span></li>
<li class="fragment">The <strong>kernel trick</strong>:
<ul>
<li class="fragment">Forget about specifying <span class="math inline">\(h(x_i): \mathbb{R}^p \to \mathbb{R}^q\)</span>!</li>
<li class="fragment">Focus on specifying kernel functions <span class="math inline">\(K(x_i, x_j): \mathbb{R}^p \times \mathbb{R}^p \to \mathbb{R}\)</span></li>
<li class="fragment">That is, flexible similarity functions between feature vectors</li>
</ul></li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>אז בואו נקרא לפונקציה הזאת קרנל, נסמן אותה כפונקציה K של שני וקטורים או שתי תצפיות במרחב המקורי של X.</p>
<p>ואם נחזור למודל שלנו של המישור שמפריד בין הקלאסים במרחב של h אנחנו רואים שאפשר להציב את הקרנל הזה במקום המכפלה הפנימית של הhים ולקבל ביטוי פשוט יותר.</p>
<p>אז מה הטריק?</p>
<p>הטריק הוא שמאוד יכול להיות שאני לא צריך לחשב בכלל את h, ויותר מזה אני לא צריך לפרט אותה!</p>
<p>במקום זה אני מפרט פונקצית קרנל כלשהי בין התצפיות, שעבור כל שתי תצפיות בRp אומרת לי כמה הן דומות בעצם.</p>
<p>זה הרבה יותר קל לחשוב ככה, ובאמת יש כל מיני פונקצית קירבה בין תצפיות שמסתתרת מאחוריהן פיצ’ר מאפ h מאוד מאוד מעניינת, ממימד אולי מאוד גבוה, שמאפשרת מודל מאוד מאוד גמיש בלי לחשב אותה.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="common-kernels">Common kernels</h3>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 38%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th>kernel</th>
<th><span class="math inline">\(K(x_i, x_j)\)</span></th>
<th>comment</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Linear</td>
<td><span class="math inline">\(\langle x_i, x_j \rangle\)</span></td>
<td>SVC!</td>
</tr>
<tr class="even">
<td>Polynomial</td>
<td><span class="math inline">\((1 + \langle x_i, x_j \rangle)^d\)</span></td>
<td>For <span class="math inline">\(p = 2, d = 2\)</span> we got <span class="math inline">\(h(x)\)</span></td>
</tr>
<tr class="odd">
<td>Gaussian/SE/RBF</td>
<td><span class="math inline">\(\exp\left(-\gamma\|x_i - x_j\|^2\right)\)</span></td>
<td>infinite feature mapping space!</td>
</tr>
<tr class="even">
<td>Sigmoid</td>
<td><span class="math inline">\(\tanh(\kappa_1\langle x_i, x_j \rangle + \kappa_2)\)</span></td>
<td></td>
</tr>
</tbody>
</table>
<p><br></p>
<div>
<ul>
<li class="fragment"><p>Each of these <em>implicitly</em> uses some mapping <span class="math inline">\(h(x)\)</span>, but always: <span class="math inline">\(K(x_i, x_j) = \langle h(x_i), h(x_j) \rangle\)</span></p></li>
<li class="fragment"><p>On entire training set need to compute: <span class="math inline">\(K_{n \times n}\)</span> (kernel matrix) where <span class="math inline">\(K_{ij} = K(x_i, x_j) = \langle h(x_i), h(x_j) \rangle\)</span></p></li>
</ul>
</div>
<div class="fragment">
<div class="callout callout-note callout-style-simple">
<div class="callout-body">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-content">
<p>Can any <span class="math inline">\(K(x_i, x_j): \mathbb{R}^p \times \mathbb{R}^p \to \mathbb{R}\)</span> function use as a kernel?</p>
</div>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>הנה כמה פונקציות כאלה או קרנלים כמו שנהוג לקרוא להם:</p>
<p>לדוגמא הקרנל הליניארי – מידת הדמיון בין שתי תצפיות היא המכפלה הפנימית ביניהן. זה כמובן מחזיר אותנו למודל המקורי, לסאפורט וקטור קלסיפייר. ולמה שהמכפלה הפנימית בין זוג וקטורים תהיה מידה לקרבה ביניהם? כי זה בדיוק קוסינוס הזווית בין שני הוקטורים, עד כדי קבוע, למי שזוכרים.</p>
<p>יש את הקרנל הפולינומיאלי שכרגע ראינו דוגמה שלו, באופן כללי אפשר להעלות את המכפלה הפנימית של האיקסים בחזקת d וזה מבטיח שיש לנו פיצ’ר מאפ h שכוללת את כל החזקות והאינטראקציות עד מקדם d כולל.</p>
<p>קרנל מאוד פופולרי ושימושי הוא הקרנל הגאוזייני או סקוורד אקספוננשיאל, או RBF. כאן תשימו לב שככל שהתצפיות דומות המרחק ביניהן קטן ומקבלים אקספוננט בחזקת אפס במקסימום, 1. למה זה קרנל מאוד שימושי? כי הוא מאפשר גבולות החלטה מעוגלים, שמאחוריהם עומדת פיצ’ר מאפ h שהיא ממימד אינסופי! שלא צריך לפרט או לחשב! לא נוכיח את זה כאן כמובן.</p>
<p>מכל מקום מובטח לכם שמאחורי כל אחד מהקרנלים האלה עומדת מכפלה פנימית של פיצ’ר מאפס שמחושבות רק באופן אימפליסיטי.</p>
<p>והרבה פעמים אנחנו לא נדבר על פונקצית קרנל אלא על מטריצת קרנל או מטריצת גרם שמחושבת על כל מדגם הלמידה בגודל n על n.&nbsp;כל איבר ij במטריצה הוא הוא הקרנל בין תצפיות i וj.</p>
<p>שאלה מתבקשת היא כמובן, מה אני יכול להשתמש בכל פונקצית דמיון שבא לי? והתשובה היא כמובן שלא. הרי כל איבר צריך להיות מכפלה של איזושהי פיצ’ר מאפ h. נגיד שקריטריון מספיק לקבוע שזה אכן כך הוא שK היא מטריצה סימטרית חיובית למחצה, ונשאיר לכם אולי בתרגיל לברר למה זה נכון.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="support-vector-machines-svm-1">Support vector machines (SVM)</h3>
<div id="f4bc040b" class="cell" data-execution_count="11">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c11_svm_files/figure-revealjs/cell-12-output-1.png" width="666" height="376"></p>
</figure>
</div>
</div>
</div>
<div class="fragment">
<div class="callout callout-note callout-style-simple">
<div class="callout-body">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-content">
<p>Notice this might add a few hyperparameters, including the kernel itself!</p>
</div>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>אז השילוב הזה של סאפורט וקטור קלאסיפיירז והטריק של קרנל הוא שמביא אותנו לסאפורט וקטור משינז.</p>
<p>הנה הביצועים של המודל החזק הזה על הדאטא הקשה לקליספיקציה שהטריד אותנו. אפשר לראות שגם קרנל RBF וגם קרנל פולינמיאלי נגיד מדרגה 6, מצליחים במשהו לקלוט את גבול ההחלטה העקום והלא רציף הזה. הקרנל הRBF קצת יותר.</p>
<p>ורק נזכיר שמודל כל כך חזק לא בא בלי מחיר לשלם. מחיר אחד למשל אתם רואים כאן, לכל קרנל נוספים פרמטרים שצריך לבחור, כנראה עם קרוס ולידיישן. בקרנל הRBF צריך לבחור את הרזולוציה גאמא, בקרנל הפולינומיאלי צריך לבחור את הדרגה d.&nbsp;ויותר מזה צריך לבחור את הקרנל עצמו. בדרך כלל הבחירה היא בין כמה קרנלים נפוצים יותר, אבל אתם יודעים כמה קרנלים פותחו עם השנים? עשרות.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="example-saheart-data">Example: SAHeart data</h3>
<div id="59aed34b" class="cell" data-execution_count="12">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c11_svm_files/figure-revealjs/cell-13-output-1.png" width="455" height="449"></p>
</figure>
</div>
</div>
</div>
<div class="fragment">
<div class="callout callout-note callout-style-simple">
<div class="callout-body">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-content">
<p>Notice to compute ROC SVM needs to output a probability or score.</p>
<p>This is out of scope, but you could think of the distance of an observation to the hyperplane as a type of confidence.</p>
</div>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>מחיר נוסף שאנחנו משלמים עם מודל כל כך חזק הוא הסיכוי לאוברפיטינג. אפשר לראות את זה כאן כשאנחנו מפעילים SVM על נתונים אמיתיים, הנתונים שהצגנו על מדגם של פציינטים שחלקם קיבלו התקף לב וחלקם לא, ואנחנו רוצים לחזות על מדגם טסט, על פציינטים חדשים. כאן אני משווה על מדגם הטסט, על חולים שהמודל לא ראה, בין רגרסיה לוגיסטית לבין SVM עם קרנל ליניארי, קרנל פולינומיאלי מדרגה 2 וקרנל RBF. ואפשר לראות מהAUC גם שהקרנלים הכי פשוטים מגיעים לתוצאות הכי טובות, וגם שרגרסיה לוגיסטית מגיעה בשורה התחתונה לביצועים דומים מאוד לSVM עם קרנל ליניארי שהוא בעצם SVC כמו שצפינו.</p>
<p>חדי העין בטח שואלים את עצמם רגע, איך אני בכלל מצייר עקומת ROC למודל SVM, הוא הרי מחזיר חיזויים של 1 או מינוס 1, ואנחנו צריכים איזו הסתברות או לפחות איזשהו סקור כדי לצייר ROC, עם קטאופים שונים. אז זה כבר קצת מחוץ לסקופ שלנו, אבל יש דרך לחלץ סקור ואפילו הסתברות ממודל SVM, לכל הפחות ודאי אפשר להתייחס למרחק של כל תצפיות מהמישור שנוצר כאיזושהי מטריקה של קונפידנס. ככל שתצפית רחוקה יותר מהמישור, כך המודל בטוח לגביה שהיא מקלאס אחד ולא מאחר.</p>
<p>ומה עם יותר מקלאס אחד? ומה עם רגרסיה? נגיד גם על זה כמה מילים בחלק האחרון של היחידה.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="svm-extensions" class="slide level2 title-slide center">
<h2>SVM extensions</h2>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>ניגע כעת קצת בהרחבות של SVM ליותר משני קלאסים ולרגרסיה. ההרחבה של SVM ליותר משני קלאסים היא יחסית קלה ומתאימה לא רק לSVM אלא לכל מודל שיודע לעשות הפרדה לשני קלאסים בלבד. ההרחבה של SVM לרגרסיה היא מעט יותר מתוחכמת ולא נוכל להיכנס לכל הפרטים והדקויות, אבל בודאי תבינו כיצד היא מתבצעת.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="svm-for-k-classes">SVM for <span class="math inline">\(K\)</span> classes</h3>
<ul>
<li>One-versus-one (OVO):
<ul>
<li>Run all <span class="math inline">\(K \choose 2\)</span> pairwise models: class <span class="math inline">\(k\)</span> vs.&nbsp;class <span class="math inline">\(k'\)</span></li>
<li>Assign <span class="math inline">\(x_0\)</span> to class <span class="math inline">\(k\)</span> to which it was most frequently assigned to</li>
</ul></li>
<li>One-versus-rest (OVR):
<ul>
<li>Run all <span class="math inline">\(K\)</span> models: class <span class="math inline">\(k\)</span> (<span class="math inline">\(+1\)</span>) vs.&nbsp;remaining <span class="math inline">\(K - 1\)</span> classes (<span class="math inline">\(-1\)</span>)</li>
<li>Assign <span class="math inline">\(x_0\)</span> to class <span class="math inline">\(k\)</span> in which it gets the highest distance (confidence) from hyperplane <span class="math inline">\(\hat{\beta}_{0k} + x_0^T\hat{\beta_{k}}\)</span></li>
</ul></li>
</ul>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>אז איך מרחיבים SVM ליותר משני קלאסים – איך שמרחיבים כל מודל בינארי ליותר משני קלאסים.</p>
<p>דרך אחת היא וואן-ורסוז-וואן או OVO. נריץ SVM להפרדה בין כל זוג קלאסים K וK טאג. סך הכל נריץ SVM K מעל 2 פעמים. וכשמגיעה תצפית חדשה נעביר אותה בכל המודלים ונסווג אותה אל הקלאס אליו היא שויכה הכי הרבה פעמים, לעומת הקלאסים האחרים.</p>
<p>הדרך השניה היא וואן-ורסוז-רסט או OVR. נחלק את הדאטא לקלאס הk מול כל שאר התצפיות ונריץ SVM. נעשה את זה לכל קלאס וקלאס, בסך הכל נריץ SVM K פעמים. וכשמגיעה תצפית חדשה, נעביר אותה בכל המודלים, ונסווג אותה אל הקלאס שבמודל שלו היא הראתה הכי הרבה קונפידנס שהיא שייכת אליו, כלומר כמו שראינו הכוונה היא למודל עם המישור שממנו התצפית הכי רחוקה.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="support-vector-regression-svr">Support vector regression (SVR)</h3>
<div id="795a6c82" class="cell" data-execution_count="13">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="c11_svm_files/figure-revealjs/cell-14-output-1.png" width="659" height="429"></p>
</figure>
</div>
</div>
</div>
<div class="fragment">
<div class="callout callout-note callout-style-simple">
<div class="callout-body">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-content">
<p>What would be the support vectors for SVR?</p>
</div>
</div>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>ומה עם רגרסיה? איך נבטא רעיון דומה של מישור שמבטא באמצעות איזשהו מרג’ין ממנו את הקשר הכי טוב בין משתנה מסביר X לY רציף?</p>
<p>נתחיל בזה שמישור הוא בדיוק מה שאנחנו מחפשים תמיד ברגרסיה, למשל עם משתנה אחד מדובר בקו. ונגדיר שאנחנו רוצים מישור עם מרג’ין M סביבו (להדגים), שכל התצפיות נכנסות בו, בלוח הזה. זה מאוד הגיוני, כי ככל שהמרג’ין קטן יותר זה אומר שהפיזור סביב המישור קטן יותר וזו התאמה טובה יותר. ככל שהוא גדול יותר כך הפיזור גדול ואנחנו פחות בטוחים במודל, בדומה לרגרסיה.</p>
<p>עכשיו זה כמובן קריטריון מחמיר מאוד ומושפע בקלות מתצפיות קיצוניות, ולכן גם כאן אנחנו עושים רילקסציה ומאפשרים משתני סלאק לתצפיות מסוימות, שיוצאות מהמרג’ין. אפשר להגדיר בדיוק כמו מקודם שיש לנו איזשהו תקציב C לגודל הסלאק או מספר התצפיות שאנחנו מוכנים שיצאו מהמרג’ין ולהמשיך בצורה דומה מאוד לSVM.</p>
<p>עכשיו נאמר והשגנו את זה כמו בתרשים שלפנינו – אילו נקודות הן הסאפורט וקטורז, שרק בהן המודל הסופי בעצם תלוי? כאן אלה דווקא התצפיות מחוץ למרג’ין, שאם הן יזוזו המישור והמרג’ין יכולים מאוד להשתנות. זה קצת שונה מSVM אבל אם תחשבו על זה זה ממש אותו עקרון – על תצפיות שבתוך המרג’ין אנחנו לא משלמים כלום, העיקר שהן רחוקות עד כדי M מהמישור. אנחנו משלמים הרבה על התצפיות שמחוץ למרג’ין, לכן הן הסאפורט וקטורז.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="svr-criterion">SVR Criterion</h3>
<div>
<ul>
<li class="fragment"><p>From maximum margin classifier: <span class="math inline">\(\max_{\beta, \beta_0}M \quad s.t. \space \|\beta\| = 1 \text{ and } \quad y_i (\beta_0 + x_i^T\beta) \ge M \quad \forall i\)</span></p></li>
<li class="fragment"><p>To “maximum margin regressor” (not really a thing): <span class="math inline">\(\max_{\beta, \beta_0}M \quad s.t. \space \|\beta\| = 1 \text{ and } \quad |y_i - (\beta_0 + x_i^T\beta)| \le M \quad \forall i\)</span></p></li>
<li class="fragment"><p>From SVC: <span class="math inline">\(\max_{\beta, \beta_0, \epsilon}M \quad s.t. \space \|\beta\| = 1, \quad y_i (\beta_0 + x_i^T\beta) \ge M(1-\epsilon_i), \quad \epsilon_i \ge 0, \quad \sum_{i = 1}^n \epsilon_i \le C\)</span></p></li>
<li class="fragment"><p>To SVR: <span class="math inline">\(\max_{\beta, \beta_0, \epsilon}M \quad s.t. \space \|\beta\| = 1, \quad |y_i - (\beta_0 + x_i^T\beta)| \le M + \epsilon_i, \quad \epsilon_i \ge 0, \space \sum_{i = 1}^n \epsilon_i \le C\)</span></p></li>
<li class="fragment"><p>Though this is more common: <span class="math display">\[\min_{\beta, \beta_0, \epsilon}\frac{1}{2}\|\beta\|^2 + C \sum_{i = 1}^n \epsilon_i \quad s.t. \space |y_i - (\beta_0 + x_i^T\beta)| \le M + \epsilon_i, \space \epsilon_i \ge 0\]</span></p></li>
<li class="fragment"><p>And of course SVR can be kernelized as well</p></li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>פורמלית אפשר בשקף אחד להראות את כל המסע שלנו בדרך לSVM רק ברגרסיה, המסע לSVR.</p>
<p>בקלסיפיקציה היה לנו את הקריטריון המחמיר של מקסימום מרג’ין קלסיפייר.</p>
<p>ברגרסיה אפשר לחשוב על קריטריון מקביל, להביא למקסימום את המרג’ין, כך שוקטור המקדמים הוא וקטור יחידה, ונדאג שכל תצפית רחוקה מהמישור, כלומר מהחיזוי שלה עד כדי המרג’ין M. שימו לב להבדל כאן בין קלסיפיקציה לרגרסיה.</p>
<p>אחר-כך הרשינו קצת סלאק והגענו לקריטריון של סאפורט וקטור קלסיפייר.</p>
<p>ואפשר לחשוב על קריטריון מקביל ברגרסיה: נרצה את המקסימום מרג’ין כך שכל תצפית רחוקה לא יותר מM מהחיזוי שלה, ונוסיף משתני סלאק גדולים מאפס, לחלק מהתצפיות אנחנו מרשים להיות רחוקות מעבר למרג’ין. ועל משתני הסלאק שולט פרמטר של תקציב C.</p>
<p>בפועל, כמו בקלסיפיקציה תראו יותר בספרות קריטריון שנראה כך: מינימום על הנורמה של המקדמים בריבוע, כדי לעשות את זה בעיה קמורה, ועוד פרמטר פנאלטי על סכום משתני הסלאק. גם בעית אופטימיזציה שיש לה פתרונות סטנדרטיים. כאן, רק נשים לב שלא נפטרנו מפרמטר הM שמייצג את המרג’ין, נהוג לפרט גם אותו למשל במימוש של sklearn.</p>
<p>וגם למודל של SVR ניתן לעשות קרנליזציה ולהתחשב בקרנלים שונים.</p>
<p>נעצור כאן, כמו שאמרנו יש עוד הרבה יותר מה להגיד על SVR, ואפשר להראות שגם הוא וגם SVM עושים מינימום לפונקציות לוס מעניינות מאוד, מי שמעוניין בכך יכול לקרוא על כך עוד בספרים.</p>
<p>עד כאן SVM, אחד המודלים האלגנטיים ביותר בלמידת מכונה שיודע גם לטפל בדאטא ממימד גדול מאוד ולכן גם היה אופנתי מאוד ככל שהנתונים נעשו גדולים ועד שהגיעו רשתות הנוירונים.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
<div class="quarto-auto-generated-content">
<p><img src="../Intro2SL_logo_white.jpg" class="slide-logo"></p>
<div class="footer footer-default">
<p><a href="https://intro2statlearn.github.io/mooc/" target="_blank">Intro to Statistical Learning</a></p>
</div>
</div>
</section>
    </div>
  </div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="../libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="../libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="../libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="../libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="../libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="../libs/revealjs/plugin/reveal-chalkboard/plugin.js"></script>
  <script src="../libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="../libs/revealjs/plugin/notes/notes.js"></script>
  <script src="../libs/revealjs/plugin/search/search.js"></script>
  <script src="../libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="../libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': false,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleChalkboard(event)\"><kbd>b</kbd> Toggle Chalkboard</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleNotesCanvas(event)\"><kbd>c</kbd> Toggle Notes Canvas</a></li>\n<li class=\"slide-tool-item\" data-item=\"6\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.downloadDrawings(event)\"><kbd>d</kbd> Download Drawings</a></li>\n<li class=\"slide-tool-item\" data-item=\"7\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'chalkboard': {"buttons":true},
'smaller': true,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'none',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1050,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        math: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, RevealChalkboard, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script id="quarto-html-after-body" type="application/javascript">
    window.document.addEventListener("DOMContentLoaded", function (event) {
      const toggleBodyColorMode = (bsSheetEl) => {
        const mode = bsSheetEl.getAttribute("data-mode");
        const bodyEl = window.document.querySelector("body");
        if (mode === "dark") {
          bodyEl.classList.add("quarto-dark");
          bodyEl.classList.remove("quarto-light");
        } else {
          bodyEl.classList.add("quarto-light");
          bodyEl.classList.remove("quarto-dark");
        }
      }
      const toggleBodyColorPrimary = () => {
        const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
        if (bsSheetEl) {
          toggleBodyColorMode(bsSheetEl);
        }
      }
      toggleBodyColorPrimary();  
      const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
      tabsets.forEach(function(tabset) {
        const tabby = new Tabby('#' + tabset.id);
      });
      const isCodeAnnotation = (el) => {
        for (const clz of el.classList) {
          if (clz.startsWith('code-annotation-')) {                     
            return true;
          }
        }
        return false;
      }
      const clipboard = new window.ClipboardJS('.code-copy-button', {
        text: function(trigger) {
          const codeEl = trigger.previousElementSibling.cloneNode(true);
          for (const childEl of codeEl.children) {
            if (isCodeAnnotation(childEl)) {
              childEl.remove();
            }
          }
          return codeEl.innerText;
        }
      });
      clipboard.on('success', function(e) {
        // button target
        const button = e.trigger;
        // don't keep focus
        button.blur();
        // flash "checked"
        button.classList.add('code-copy-button-checked');
        var currentTitle = button.getAttribute("title");
        button.setAttribute("title", "Copied!");
        let tooltip;
        if (window.bootstrap) {
          button.setAttribute("data-bs-toggle", "tooltip");
          button.setAttribute("data-bs-placement", "left");
          button.setAttribute("data-bs-title", "Copied!");
          tooltip = new bootstrap.Tooltip(button, 
            { trigger: "manual", 
              customClass: "code-copy-button-tooltip",
              offset: [0, -8]});
          tooltip.show();    
        }
        setTimeout(function() {
          if (tooltip) {
            tooltip.hide();
            button.removeAttribute("data-bs-title");
            button.removeAttribute("data-bs-toggle");
            button.removeAttribute("data-bs-placement");
          }
          button.setAttribute("title", currentTitle);
          button.classList.remove('code-copy-button-checked');
        }, 1000);
        // clear code selection
        e.clearSelection();
      });
        var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
        var mailtoRegex = new RegExp(/^mailto:/);
          var filterRegex = new RegExp('/' + window.location.host + '/');
        var isInternal = (href) => {
            return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
        }
        // Inspect non-navigation links and adorn them if external
     	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
        for (var i=0; i<links.length; i++) {
          const link = links[i];
          if (!isInternal(link.href)) {
            // undo the damage that might have been done by quarto-nav.js in the case of
            // links that we want to consider external
            if (link.dataset.originalHref !== undefined) {
              link.href = link.dataset.originalHref;
            }
          }
        }
      function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
        const config = {
          allowHTML: true,
          maxWidth: 500,
          delay: 100,
          arrow: false,
          appendTo: function(el) {
              return el.closest('section.slide') || el.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'light-border',
          placement: 'bottom-start',
        };
        if (contentFn) {
          config.content = contentFn;
        }
        if (onTriggerFn) {
          config.onTrigger = onTriggerFn;
        }
        if (onUntriggerFn) {
          config.onUntrigger = onUntriggerFn;
        }
          config['offset'] = [0,0];
          config['maxWidth'] = 700;
        window.tippy(el, config); 
      }
      const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
      for (var i=0; i<noterefs.length; i++) {
        const ref = noterefs[i];
        tippyHover(ref, function() {
          // use id or data attribute instead here
          let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
          try { href = new URL(href).hash; } catch {}
          const id = href.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note) {
            return note.innerHTML;
          } else {
            return "";
          }
        });
      }
      const findCites = (el) => {
        const parentEl = el.parentElement;
        if (parentEl) {
          const cites = parentEl.dataset.cites;
          if (cites) {
            return {
              el,
              cites: cites.split(' ')
            };
          } else {
            return findCites(el.parentElement)
          }
        } else {
          return undefined;
        }
      };
      var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
      for (var i=0; i<bibliorefs.length; i++) {
        const ref = bibliorefs[i];
        const citeInfo = findCites(ref);
        if (citeInfo) {
          tippyHover(citeInfo.el, function() {
            var popup = window.document.createElement('div');
            citeInfo.cites.forEach(function(cite) {
              var citeDiv = window.document.createElement('div');
              citeDiv.classList.add('hanging-indent');
              citeDiv.classList.add('csl-entry');
              var biblioDiv = window.document.getElementById('ref-' + cite);
              if (biblioDiv) {
                citeDiv.innerHTML = biblioDiv.innerHTML;
              }
              popup.appendChild(citeDiv);
            });
            return popup.innerHTML;
          });
        }
      }
    });
    </script>
    

</body></html>